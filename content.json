{"pages":[],"posts":[{"title":"1.1 数组链表","text":"Preface这部分是有关数组和链表的算法，包括：前缀和、差分数组、双指针、滑动窗口、二分搜索、递归、田忌赛马等。 关于基础数据结构基础数据结构包括：数组、链表、队列、栈等，因为都比较类似、操作过程不怎么涉及递归，所以都归纳成较为基础的数据结构 数组/链表数组、链表代表计算机最基本的两种存储形式：顺序存储、链式存，因此也是最基本的数据结构。 数组链表的主要算法技巧： 双指针 中间向两端扩散的双指针 两端向中间收缩的双指针、快慢指针 前缀和技巧 差分数组技巧 前缀和数组题目LeetCode：303、304、560 应用适用于快速、频繁地计算一个索引区间内的元素之和 核心代码1234567891011121314class PrefixSum{ private int[] prefix; public PrefixSum(int[] nums){ prefix = new int[nums.length+1]; for(int i = 1; i &lt; prefix.length; i++){ prefix[i] = prefix[i-1]+nums[i-1]; } } /* 闭区间[i, j] 的累加和*/ public int query(int i, int j){ return prefix[j+1]-prefix[i]; }} 差分数组题目370， 1109， 1094 应用频繁对原始数组的某个区间的元素进行增减 例子 我给你输⼊⼀个数组 nums，然后⼜要求给区间 nums[2..6] 全部加 1，再给 nums[3..9] 全部减 3，再给 nums[0..4] 全部加 2，再给… 问最后 nums 数组的值是什么？ 框架构造一个diff差分数组，diff[i] 就是 nums[i]-nums[i-1] 123456int[] diff = new int[nums.length];//构造差分数组diff[0] = nums[0];for(int i = 1; i &lt; nums.length; i++){ diff[i] = nums[i] - nums[i-1];} 利用差分数组diff反推出原始数组nums： 123456int[] res = new int[diff.length];//根据差分数组构造结果数组res[0] = diff[0];for(int i = 1; i &lt; diff.length; i++){ res[i] = res[i-1] + diff[i];} 如果想对区间nums[i..j]的元素全部加3，只要让diff[i] += 3， 然后再让diff[j+1] -= 3即可 原理很简单，回想 diff 数组反推 nums 数组的过程，diff[i] += 3 意味着给 nums[i..] 所有的元素都 加了 3，然后 diff[j+1] -= 3 ⼜意味着对于 nums[j+1..] 所有元素再减 3，那综合起来，是不是就是对 nums[i..j] 中的所有元素都加 3 了？ 只要花费 O(1) 的时间修改 diff 数组，就相当于给 nums 的整个区间做了修改。多次修改 diff，然后通过 diff 数组反推，即可得到 nums 修改后的结果 1234567891011121314151617181920212223242526272829303132class Difference{ //差分数组 private int[] diff; /*输入一个初始数组，区间操作将在这个数组上进行*/ public Difference(int[] nums){ assert nums.length &gt; 0; diff = new int[nums.length]; diff[0] = nums[0]; for(int i = 1; i &lt; nums.length; i++){ diff[i] = nums[i] - nums[i-1]; } } /*给闭区间[i,j]增加val (val可以为负)*/ public void increment(int i, int j, int val){ diff[i] += val; if(j + 1 &lt; diff.length){ diff[j+1] -= val; } } /*返回结果数组*/ public int[] result(){ int[] res = new int[diff.length]; res[0] = diff[0]; for(int i = 1; i &lt; diff.length; i++){ res[i] = res[i-1] + diff[i]; } return res; }} 当 j+1 &gt;= diff.length 时，说明是对 nums[i] 及以后的整个数组都进⾏修改，那么就不需要再给 diff 数组减 val 了。 双指针技巧秒杀链表题目21、23、141、142、876、19、160 应用单链表常见算法题： 合并两个有序链表 合并k个有序链表 寻找单链表的倒数第k个节点 寻找单链表的中点 判断单链表是否包含环并找出环起点 判断两个单链表是否相交并找出交点 上述都用到了双指针技巧 框架合并两个有序链表这个算法的逻辑类似于【拉拉链】，l1, l2 类似拉链两侧的锯齿，p就像拉链的拉索，将两个有序链表合并。 链表的算法题中常见的技巧：虚拟头结点，也就是dummy结点。 123456789101112131415161718192021222324252627ListNode mergeTwoLists(ListNode l1, ListNode l2){ //虚假头结点 ListNode dummy = new ListNode(-1), p = dummy; ListNode p1 = l1, p2 = l2; while(p1 != null &amp;&amp; p2 != null){ //比较p1 p2两个指针 //将小的节点接在p指针后面 if(p1.val &gt; p2.val){ p.next = p2; p2 = p2.next; }else{ p.next = p1; p1 = p1.next; } p = p.next; } if(p1 != null){ p.next = p1; } if(p2 != null){ p.next = p2; } return dummy.next;} 合并k个有序链表难点：如何快速得到k个结点中的最小结点，接到结果链表上。 解决：使用优先级队列（二叉堆），把链表结点放入一个最小堆，就可以每次获得k个结点中的最小结点。 1234567891011121314151617181920212223242526ListNode mergeKLists(ListNode[] lists){ if(lists.length == 0) return null; //虚拟头结点 ListNode dummy = new ListNode(-1); ListNode p = dummy; //优先级队列，最小堆 PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;( lists.length, (a, b) -&gt; (a.val - b.val)); //将k个链表的头结点加入最小堆 for(ListNode head: lists){ if(head != null) pq.add(head); } while(!pq.isEmpty()){ //获取最小结点，接到结果链表中 ListNode node = pq.poll(); p.next = node; if(node.next != null){ pq.add(node.next); } //p指针不断前进 p = p.next; } return dummy.next;} 复杂度分析： 优先队列pq中的元素个数最多是k， 所以一次 poll 或者 add 的时间复杂度是O(logk) 所有链表的节点都会被加入和弹出pq， 所以算法整体的时间复杂度是O(Nlogk)，其中k是链表的条数， N是这些链表的节点总数 单链表的倒数第k个结点 最暴力的方法：【两次遍历】 先从头遍历得出链表长度，然后再次遍历计算得到第 n-k+1个节点 双链表解法：【双指针一次遍历】 先让指针p1指向链表的头结点head，走k步；此时p1只用再走n-k步，就可以走到链表末尾的空指针 然后让指针p2指向链表头结点head 123456789101112131415ListNode findFromEnd(ListNode head, int k){ ListNode p1 = head; //p1 先走k步 for(int i = 0; i &lt; k; i++){ p1 = p1.next; } ListNode p2 = head; // p1 p2同时走 n-k 步 whle(p1 != null){ p2 = p2.next; p1 = p1.next; } //p2 现在指向第n-k个结点 return p2;} 时间复杂度分析 用big O表示法来计算时间复杂度，遍历1次or2次时间复杂度都是O(N)，但是这个算法更有技巧性。 注意 不过注意我们使用了虚拟头结点的技巧，也是为了防止出现空指针的情况，比如说链表总共有 5 个节点， 题⽬就让你删除倒数第 5 个节点，也就是第⼀个节点，那按照算法逻辑，应该⾸先找到倒数第 6 个节点。但 第⼀个节点前面已经没有节点了，这就会出错。但有了我们虚拟节点 dummy 的存在，就避免了这个问题，能够对这种情况进行正确的删除。 单链表的中点对应LeetCode 876 暴力 先遍历链表计算链表长度n，然后再遍历一次得到第n/2个结点 快慢指针 慢指针走1步，快指针走2步，快指针走到末尾，慢指针就走到了中点. 当链表长度为偶数时，返回的节点是靠后的节点。 123456789ListNode middleNode(ListNode head){ //快慢指针初始化指向head ListNode slow = head, fast = head; while(fast != null &amp;&amp; fast.next != null){ slow = slow.next; fast = fast.next.next; } return slow;} 判断链表是否包含环 快慢指针 slow走1步，fast走2步，如果fast最终遇到空指针，说明没有环，如果fast和slow最终相遇，说明fast超过slow一圈，说明链表中有环。 题目：141 easy 12345678910111213boolean hasCycle(ListNode head){ //快慢指针初始化指向head ListNode slow = head, fast = head; //快指针走到末尾时停止 while(fast != null &amp;&amp; fast.next != null){ //慢指针走一步，快指针走2步 slow = slow.next; fast = fast.next.next; if(slow == fast) return true; } return false;} 判断环的起点 题目：142 Medium 解析 我们假设快慢指针相遇时，慢指针 slow 走了 k 步，那么快指针 fast 一定走了 2k 步。 这多走的k步其实就是在环里面转圈，所以k的值就是环长度的整数倍。 假设相遇点距环的起点距离为m，慢指针走了k步，则环起点距离head有k-m步。所以从相遇点开始走k步就可以转回到相遇点，走k-m步就是走到环起点。 12345678910111213141516171819202122ListNode detectCycle(ListNode head){ ListNode fast, slow; fast = slow = head; while(fast != null &amp;&amp; fast.next != null){ fast = fast.next.next; slow = slow.next; if(slow = fast) break; } if(fast == null || fast.next == null) //说明没有环 return null; //重新指向头结点 slow = head; //快慢指针同步进行，相交点就是环起点 while(slow != fast){ fast = fast.next; slow = slow.next; } return slow;} 两个链表是否相交 题目：160 暴力法： 用HastSet记录一个链表的所有结点，然后和另一条链表对比，这需要额外空间 双指针： 让p1遍历完A链表，之后开始遍历B链表。 让p2遍历完B链表后开始遍历A链表，这样逻辑上连接在一起。 这样拼接可以使p1 p2同时进入公共部分，达到交点。 如果没有交点，返回null 1234567891011121314151617181920212223242526ListNode getIntersectionNode(ListNode heada, ListNode headb){ //p1 指向 A链表头结点，p2指向B链表头结点 ListNode p1 = head1, p2 = headb; while(p1 != p2){ //p1 走一步，如果走到A链表末尾，转到B链表 if(p1 == null){ p1 = headb; }else{ p1 = p1.next; } //p2 走1步，如果走到B链表末尾，转到A链表 if(p2 == null){ p2 = heada; }else{ p2 = p2.next; } } return p1; //上面也可以变成 while(p1 != p2){ p1 = p1 == null ? headB : p1.next; p2 = p2 == null ? headA : p2.next; } return p1;} 注意：判断条件一定是p1 or p2 == null? 而不是p1.next or p2.next == null吗，否则会出现不相交，然后一直在while里面死循环的情况。 复杂度 空间复杂度O(1)，时间复杂度O(N) 转换成环的问题：将两条链表首尾相连，转换成求环起点问题 1234567891011121314151617181920212223242526272829ListNode getIntersectionNode(ListNode heada, ListNode headb){ int lena = 0, lenb = 0; //计算两条链表长度 for(ListNode p1 = heada; p1 != null; p1 = p1.next){ lena++; } for(ListNode p2 = headb; p2 != null; p2 = p2.next){ lenb++; } //让p1 和 p2达到尾部距离相同 ListNode p1 = heada, p2 = headb; if(lena &gt; lenb){ for(int i = 0; i &lt; lena - lenb; i++){ p1 = p1.next; } }else{ for(int i = 0; i &lt; lenb - lena; i++){ p2 = p2.next; } } //看两个指针是否会相同,p1==p2时有两种情况 // 1 两条链表不相交，同时走到尾部空指针 // 2 要是两条链表相交，走到两个链表的相交点 while(p1 != p2){ p1 = p1.next; p2 = p2.next; } return p1;} 虽然代码多一些，时间复杂度还是O(N) 双指针技巧秒杀数组题目26、83、27、283、167、344、5 在处理数组和链表的时候，双指针技巧经常使用，主要技巧分为两类：左右指针和快慢指针。 左右指针：两个指针相向而行或相背而行 快慢指针：两个指针同向而行，一快一慢 对单链表来说，大部分技巧属于快慢指针。 在数组中没有真正意义上的指针，所以可以把索引当做数组中的指针，这样也可以在数组中施展双指针。 快慢指针技巧场景：数组问题中比较常见且难度不高的快慢指针技巧，是让你原地修改数组。 题目： 26 删除有序数组中的重复项 83 删除排序链表中的重复元素 27 移除元素 注意！不要忘了先判断最简单的情况！ 12if (nums.length == 0) return 0; if (head == null) return null; 滑动窗口算法1234567891011121314151617181920//滑动窗口算法框架void slidingWindow(string s, string t){ unordered_map&lt;char, int&gt; need, window; for(char c: t) need[c]++; int left = 0, right = 0; int valid = 0; while(right &lt; s.size()){ char c = s[right]; //右移增大窗口 right++; //进行窗口内数据的一系列更新 while(window needs shrink){ char d = s[left]; //左移缩小窗口 left++; //进行窗口内数据的一系列更新 } }} 左右指针的常用算法二分查找前提条件：有序！ 由于其他地方有详细探讨二分搜索代码的细节问题，这里只写最简单的二分算法，旨在突出他双指针的特性 1234567891011121314int binarySearch(int[] nums, int target){ //一左一右两个指针相向而行 int left = 0, right = nums.length - 1; while(left &lt;= right){ int mid = (right + left)/2; if(nums[mid] == target) return mid; else if(nums[mid] &lt; target) left = mid+1; else if(nums[mid] &gt; target) right = mid-1; } return -1;} 两数之和题目：167 两数之和 反转数组题目：344 反转字符串 5 最长回文子串 判断是否是回文串：从两边向中间 123456789101112boolean isPalindrome(String s){ //一左一右两个指针相向而行 int left = 0, right = s.length() - 1; while(left &lt; right){ if(s.charAt(left) != s.charAt(right)){ return false; } left++; right--; } return true;} 寻找回文串，从中间向两边 回文串的长度可能是奇数也可能是偶数，所以解决问题的核心是从中心向两端扩散。 如果回文串长度是奇数，则有一个中心字符；如果是偶数，则有2个中心字符，因此可以先实现这样一个函数 12345678910//在S中寻找以s[l] s[r]为中心的最长回文串String palindrome(String s, int l, int r){ //防止索引越界 while(l &gt;= 0 &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r)){ l--; r++; } //返回s[l] 和 s[r]为中心的最长回文串 return s.substring(l+1, r);} 滑动窗口题目76 最小覆盖子串 hard 567 字符串排列 medium 438 Find All Anagrams in a String 找到字符串中所有字母异位词 medium 3 Longest Substring Without Repeating Character 最长无重复子串 medium ：如果说只有字母那可以用数组，但是没说就可能包含特殊符号，还是要用hashmap 技巧顺口溜123456789链表子串数组题，使用双针别犹豫快慢指针最神奇，链表操作无压力归并排序找中点，链表成环搞判定左右指针最常见，左右两端相向行反转数组要靠他，二分搜索是弟弟滑动窗口要背下，子串问题全靠他 框架算法思路：维护一个窗口，不断滑动 时间复杂度：O(N) 算法逻辑： 123456789101112int left = 0, right = 0;while(right &lt; s.size()){ // 增大窗口 window.add(s[right]); right++; while(window needs shrink){ //缩小窗口 window.remove(s[left]); left++; }} 算法框架： 1234567891011121314151617181920212223242526272829//滑动窗口算法框架void slidingWindow(String s, String t){ unordered_map&lt;char, int&gt; need, window; for(char c: t) need[c]++; int left = 0, right = 0; int valid = 0; while(right &lt; s.size()){ //c是将移入窗口的字符 char c = s[right]; //增大窗口 right++; //进行窗口内数据的一系列更新 // ... 更新窗口数据【扩大窗口】 //debug 输出位置 printf(&quot;window:[%d, %d]\\n&quot;, left, right); //判断左窗口是否要收缩 while(window needs shrink){ //d是将移出窗口的字符 char d = s[left]; //缩小窗口 left++; //进行窗口内数据的一系列更新 //... 更新窗口数据【缩小窗口】 } }} 上面的代码是用cpp实现的，下面解释一下： unorder_map 就是哈希表（字典），相当于 HashMap， 他的一个方法count(key)相当于java的containsKey(key) 可以判断key是否存在 可以使用方括号访问键对应的值map[key]。需要注意的是，可以这个key不存在，cpp会自动创建这个key，然后把map[key]的值赋值0。所以代码中多次出现的map[key]++相当于Java的map.put[key, map.getOrDefault(key,0)+1] 另外，Java中的integer和String这种包装类不能直接用==进行相等判断，而应该使用类的equals方法。 二分搜索题目704 Binary Search Easy 34 Find First and Last Position of Element in Sorted Array 应用【前提】有序数组 二分查找思路简单，细节是魔鬼。很多人喜欢拿整型溢出的bug说事，但二分查找真正的坑在于到底要给mid加一还是减一，while里到底用&lt;=还是&lt;。 寻找一个数 寻找左边界 寻找右边界 技巧顺口溜管他左侧还是右侧，搜索区间定乾坤 搜索一个元素时，搜索区间两端闭，while条件带等号，否则就要出问号。遇到if相等就返回，其他事情别操心。mid必须加减1，因为区间两端闭，while结束返-1。 搜索左右边界时，搜索区间要阐明，左闭右开最常见，while要用小于号，if相等别返回，利用mid锁边界，mid加减看开闭。while结束不算完，因为你还没返回，索引可能出边界，要用if来check check。 二分查找框架1234567891011121314int binarySearch(int[] nums, int target){ int left = 0, right = ...; while(...){ int mid = left + (right - left)/2; if(nums[mid] == target){ ... }else if(nums[mid] &lt; target){ left = ... }else if(nums[mid] &gt; target){ right = ... } } return ...;} 分析二分查找的一个技巧是：不要出现else，把所有情况用else if写清楚，这样可以清楚地展示所有的细节。 上面代码中…标记的部分，就是可能出现细节问题的地方，但你遇到一个二分查找的代码，首先注意这几个地方。 计算mid的时候要防止溢出，代码中left+(right-left)/2和(left+right)/2结果相同，但是有效防止了left right太大，直接相加导致溢出的情况。 寻找一个数(基本的二分搜索)搜索一个数，如果存在返回其索引，否则返回-1 12345678910111213141516int binarySearch(int[] nums, int target){ int left = 0; int right = nums.length - 1; //注意 while(left &lt;= right){ int mid = left + (right - left)/2; if(nums[mid] == target) return mid; else if(nums[mid] &lt; target){ left = mid + 1; }else if(nums[mid] &gt; target){ right = mid - 1; } } return -1;} while中循环条件是&lt;=而不是&lt; 因为初始化中right的赋值是nums.length - 1, 即最后一个元素的索引，而不是nums.length; 前者相当于两端都闭区间[left, right]，后者相当于左闭右开区间[left, right)，因为索引大小为 nums.length是越界的 这里采用[left, right]两端都闭，这个区间其实就是每次进行搜索的区间 何时停止搜索 搜索区间为空的时候。while(left &lt;= right)的终止条件是left == right +1 ，即[right + 1, right]。这时while循环结束，直接返回-1即可 while(left &lt; right)的终止条件是left == right，写成区间的形式是[right, right]，比如[2,2]，这时候区间非空，还有一个数2，如果此时就终止勋魂，2没有被搜索，直接返回-1是错的。 如果非要用while(left &lt; right)，修改成下面jike 1return nums[left] == target? left : -1; 关于left = mid + 1, right = mid -1 本算法采用的搜索区间是两端都闭，所以当发现mid不是要找的数时，直接去+1 or -1搜索即可 算法缺陷 比如 nums=[1,2,2,3]，要找的数是2，此算法返回的索引是2.但是如果要找到目标的左边界 1， 右边界2，无法处理。 当然可以找到一个target，然后左右线性搜索，是可行，但是无法保证二分查找对数级的复杂度。 寻找左侧边界的二分查找1234567891011121314151617int left_bound(int[] nums, int target){ if(nums.length == 0) return -1; int left = 0; int right = nums.length; //注意 while(left &lt; right){//注意 int mid = left + (right - left)/2; if(nums[mid] == target){ right = mid; }else if(nums[mid] &lt; target){ left = mid + 1; }else if(nums[mid] &gt; target){ right = mid; } } return left;} while中是&lt;而不是&lt;= 因为用相同的方法分析，因为right = nums.length 而不是 nums.length - 1，因此每次循环的搜索区间是[left, right)左闭右开 while循环的终止条件是left == right， 此时搜索区间[left, left)为空，所以可以正确终止 返回值为什么没有-1 函数的返回值即left变量的值取值区间是闭区间[0, nums.length]，所以简单添加两行代码就可以在正确的时候return -1; 1234567while(left &lt; right){ //...}//target 比所有数都大if(left == nums.length) return -1;//类似之前算法的处理方法return nums[left] == target? left : -1; 为什么left = mid + 1, right = mid 因为搜索区间是左闭右开，当mid被检测之后，下一步应该去mid的左侧或右侧区间搜索，即[left, mid)或[mid+1, right) 返回left不是right？ 其实都一样的，因为while的终止条件是 left == right 把right也变成nums.length - 1 因为while的退出条件是left = right + 1, 所以当target比nums中所有元素都大时，会存在left索引越界的情况 12345678910111213141516171819int left_bound(int[] nums, int target){ //搜索区间为[left, right] int left = 0, right = nums.length - 1; while(left &lt;= right){ int mid = left + (right - left)/2; if(nums[mid] &lt; target){ left = mid + 1; }else if(nums[mid] &gt; target){ right = mid - 1; }else if(nums[mid] == target){ //数据右侧边界 right = mid - 1; } } //检查出界情况 if(left &gt;= nums.length || nums[left] != target) return -1; return left;} 寻找右侧边界的二分查找这里还是常见的左闭右开的写法 123456789101112131415int right_bound(int[] nums, int target){ if(nums.length==0) return -1; int left = 0, right = nums.length; while(left &lt; right){ int mid = left + (right - left)/2; if(nums[mid] == target){ left = mid + 1; //注意 }else if(nums[mid] &lt; target){ left = mid + 1; }else if(nums[mid] &gt; target){ right = mid; } } return left - 1; //注意} 要返回-1 12345while(l &lt; r){ // ...}if(l == 0) return -1;return nums[l - 1] == target? (l - 1): -1; 逻辑统一12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152int binary_search(int[] nums, int target){ int l = 0, r = nums.length - 1; while(l &lt;= r){ int mid = l + (r - l)/2; if(nums[mid] == target){ return mid; }else if(nums[mid] &lt; target){ l = mid + 1; }else if(nums[mid] &gt; target){ r = mid - 1; } } return -1;}int left_bound(int[] nums, int target){ if(nums.length == 0) return -1; int l = 0, r = nums.length; while(l &lt; r){ int mid = l + (r - l)/2; if(nums[mid] == target){ r = mid; }else if(nums[mid] &lt; target){ l = mid + 1; }else if(nums[mid] &gt; target){ r = mid; } } if(l &gt;= nums.length || nums[l] != target){ return -1; } return l;}int right_bound(int[] nums, int target){ if(nums.length == 0) return -1; int l = 0, r = nums.length; while(l &lt; r){ int mid = l + (r - l)/2; if(nums[mid] == target){ l = mid + 1; }else if(nums[mid] &lt; target){ l = mid + 1; }else if(nums[mid] &gt; target){ r = mid; } } if(l == 0 || nums[l-1] != target){ return -1; } return l - 1;} 二分搜索套路分析题目875 Koko Eating Bananas medium 1011 Capacity To Ship Packages Within D Days medium lock 应用算法题一般都让你求最值，比如求吃东西的最小速度，轮船的最低运载能力，求最值的过程必然是一个搜索边界的过程。 【二分搜索问题的泛化】要从题目中抽象出一个自变量x，一个关于x的函数f(x)，以及一个目标值target. 要满足以下条件： f(x)必须是在x上的单调函数（单调增单调减都可以） 题目是让你计算满足约束条件f(x)==target时的x值 框架运用二分搜索解决具体问题的算法 12345678910111213141516171819202122232425262728//函数f是关于自变量x的单调函数int f(int x){ }//主函数 在f(x)==target的约束下求x的最值int solution(int[] nums, int target){ if(nums.length == 0) return -1; //问自己 自变量x的最小值是多少 int left = ...; //问自己：自变量x的最大值是多少 int right = ... + 1; while(left &lt; right){ int mid = left + (right - left)/2; if(f(mid) == target){ //问自己：题目求左边界还是右边界 //... }else if(f(mid) &lt; target){ //问自己，怎么让f(x)大一点 //... }else if(f(mid) &gt; target){ //问自己：怎么让f(x)小一点 //... } } return left;} 田忌赛马背后的算法题目870 Advantage Shuffle medium 思路打得过就打，打不过就拿自己的垃圾和对方精锐互换 框架12345678910111213int n = nums1.length;sort(nums1); //田忌的马sort(nums2); //齐王的马//从最快的马开始比for(int i = n - 1; i &gt;= 0; i--){ if(nums1[i] &gt; nums2[i]){ //比得过跟他比 }else{ //比不过 换个垫底的来送人头 }} 链表递归题目206 Reverse Linked List Easy 92 Reverse Linked List II medium 框架递归反转整个链表12345678ListNode reverse(ListNode head){ if(head == null || head.next == null) return head; ListNode last = reverse(head.next); head.next.next = head; head.next = null; return last;} 非递归写法 12345678910111213public ListNode reverseList(ListNode head) { if(head == null || head.next == null) return head; ListNode phead = new ListNode(-1); ListNode cur = head; while(cur != null){ ListNode tmp = cur.next; cur.next = phead.next; phead.next = cur; cur = tmp; } return phead.next; } 反转链表的前N个节点12345678910111213141516ListNode successor = null; //后驱节点//反转以head 为起点的n个节点，返回新的头结点ListNode reverseN(ListNode head, int n){ if(n == 1){ //记录第n+1个节点 successor = head.next; return head; } //以head.next为起点，需要反转前n-1个节点 ListNode last = reverseN(head.next, n-1); head.next.next = head; //让反转之后的head节点和后面的节点连起来 head.next = successor; return last;} 反转链表的一部分索引从1开始，如果 m=1，则相当于反转链表开头的n个元素 12345678ListNode reverseBetween(ListNode head, int m, int n){ //base case if(m == 1) return reverseN(head, n); //前进到反转的起点触发base case head.next = reverseBetween(head.next, m-1, n-1); return head;} 小结递归和迭代的时间复杂度都是O(N)，但是迭代的空间复杂度是O(1)，递归需要用到栈，空间复杂度是O(N)。 所以考虑效率的话还是迭代算法比较好","link":"/2022/04/19/1.1%20%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/"},{"title":"1.2 队列栈","text":"Preface这部分是有关队列和栈的算法，包括：括号匹配、单调栈、单调队列。 队列和栈的底层就是数组和链表封装的，队列主要用在BFS算法，栈主要用在括号相关的问题。 括号题题目20 Valid Parentheses Easy 921 Minimum Add to Make Parentheses Valid medium 1541 Minimum Insertions to Balance a Parentheses String medium 框架只有一种括号123456789101112131415161718boolean isValid(String str){ //待匹配的左括号数量 int left = 0; for(int i = 0; i &lt; str.length(); i++){ if(s[i] == '('){ left ++; }else{ //遇到右括号 left--; } //右括号太多 if(left == -1) return false; } //是否所有左括号都被匹配了 return left == 0;} 多种括号123456789101112131415161718192021222324class Solution { public boolean isValid(String str) { Stack&lt;Character&gt; left = new Stack&lt;&gt;(); for (char c : str.toCharArray()) { if (c == '(' || c == '{' || c == '[') left.push(c); else // 字符 c 是右括号 if (!left.isEmpty() &amp;&amp; leftOf(c) == left.peek()) left.pop(); else // 和最近的左括号不匹配 return false; } // 是否所有的左括号都被匹配了 return left.isEmpty(); } char leftOf(char c) { if (c == '}') return '{'; if (c == ')') return '('; return '['; }} 平衡括号串以左括号为基准，维护对右括号的需求数need，来计算最小的插入次数。 单调栈题目496 Next Greater Element I Easy 503 Next Greater Element II Medium 739 Daily Temperatures Medium 应用单调栈用途不太广泛，只处理一种典型的问题，叫做Next Greater Element。 单调栈其实就是栈，只是利用了一些巧妙的逻辑，使得每次新元素入栈后，栈内元素都保持有序（单调递增或单调递减，虽然听起来有点像堆(heap)，但是不一样。 框架给你一个数组nums，返回的结果数组中对应索引存储着下一个更大元素，如果没有更大元素就存-1. 如：nums=[2,1,2,4,3], 返回=[4,2,4,-1,-1]; 暴力解法：对每个元素后面进行扫描，找到第一个更大的元素，但是暴力解法的时间复杂度是$O(n^2)$ 聪明的解法：把数组的元素想象成并列站的人，元素大小想象成人的身高，如果能够看见元素2，那么他后面可以看见的第一个人就是2的next greater number，因此比2小的元素身高不够，都被2挡住了，第一个露出来的就是答案。 1234567891011121314151617int[] nextGreaterElement(int[] nums){ int[] res = new int[nums.length]; Stack&lt;Integer&gt; s = new Stack&lt;&gt;(); //倒着朝里面放 for(int i = nums.length - 1; i&gt;=0; i--){ //判定个子高矮 while(!s.isEmpty() &amp;&amp; s.peek() &lt;= nums[i]){ //小个子起开 s.pop(); } //nums[i] 身后的next great number res[i] = s.isEmpty() ? -1 : s.peek(); s.push(nums[i]); } return res;} 时间复杂度分析 从整体来看，共有n个元素，每个元素被push入栈了一次，而最多会被pop一次，没有任何冗余操作。 所以总的计算规模是和元素规模n成正比的，因此是O(n)的复杂度。 环形数组 解决办法： 常用的套路是将数组长度翻倍 不构造新数组，利用循环数组来模拟数组长度翻倍效果 1234for(int i = 2*n-1; i &gt;= 0; i--){ //索引要求模 // nums[i % n]; 其他都一样} 【时间复杂度】$O(N)$ 单调队列解决滑动窗口题目239 Sliding Window Maximum Hard 应用单调队列就是一个队列，不过是使用了一些巧妙的方法，使得队列中的元素全部都是单调递增或递减。 单调队列解决滑动窗口相关问题。 框架队列的操作123456class Queue{ //enqueue 在队尾加入元素n void push(int n); //dequeue 删除对头元素 void pop();} 单调队列12345678class MonotonicQueue{ //在队尾添加元素n void push(int n); //返回当前队列中的最大值 int max(); //队头元素如果是n 删除他 void pop(int n);} 12345678910111213141516171819202122232425class MonotonicQueue{ //双链表 支持头尾增删元素 private LinkedList&lt;Integer&gt; q = new LinkedList&lt;&gt;(); public void push(int n){ //将前面小于自己的元素都删除 while(!q.isEmpty() &amp;&amp; q.getLast() &lt; n){ q.pollLast(); } q.addLast(n); } public int max(){ //队头元素肯定是最大的 return q.getFirst(); } //在队头删除元素n public void pop(int n){ //判断这个是因为有可能想删除的元素n已经被压扁了不存在了，所以不用删除 if(n == q.getFirst()){ q.pollFirst(); } }} 滑动窗口最大值12345678910111213141516171819202122232425int[] maxSlidingWindow(int[] nums, int k){ MonotonicQueue window = new MonotonicQueue(); List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; nums.length; i++){ if(i &lt; k -1){ //先把窗口的前k-1填满 window.push(nums[i]); }else{ //窗口向前移动 //移入新元素 window.push(nums[i]); //将当前窗口中的最大元素记入结果 res.add(window.max()); //移出最后的元素 window.pop(nums[i - k + 1]); } } //将list转为int[]数组 int[] arr = new int[res.size()]; for(int i = 0; i &lt; res.size(); i++){ arr[i] = res.get(i); } return arr;} 复杂度分析push操作中含有while，时间复杂度应该不是O(1)，但是算法整体的复杂度依然是O(N)线性时间，nums中的每个元素最多被push和pop一次，没有任何多余操作，所以整体复杂度还是O(N)。 空间复杂度就更简单，就是窗口大小O(k) 数组去重题目316 Remove Duplicate Letters hard 1081 Smallest Subsequence of Distinct Characters medium 应用题目的要求总结出来有3点： 要去重 去重字符串顺序不能打乱字符串出现的相对顺序 在所有符合上一条要求的去重字符串中，字典序最小的作为最终结果 框架1234567891011121314151617181920212223242526272829class Solution { public String smallestSubsequence(String s) { Stack&lt;Character&gt; std = new Stack&lt;&gt;(); int[] cnt = new int[256]; boolean[] visited = new boolean[256]; StringBuilder sb = new StringBuilder(); for(char c: s.toCharArray()){ cnt[c]++; } for(char c: s.toCharArray()){ cnt[c]--; if(visited[c]) continue; while(!std.isEmpty() &amp;&amp; std.peek() &gt; c){ if(cnt[std.peek()] == 0) break; visited[std.pop()] = false; } std.push(c); visited[c] = true; } while(!std.isEmpty()){ sb.append(std.pop()); } return sb.reverse().toString(); }}","link":"/2022/04/19/1.2%20%E9%98%9F%E5%88%97%E6%A0%88/"},{"title":"1.3 数据结构设计","text":"Preface这部分是给你提需求，让你实现API，要求API的复杂度尽可能低。 经验而言，哈希表出现频率很高，一般是各类其他数据结构和哈希表组合，从而改善这些基本数据结构的特性。 LRU算法题目146 LRU Cache medium 应用LRU ( Least Recently Used) 缓存淘汰算法就是一种常用策略，也就是说我们认为最近使用过的数据应该是有用的，很久都没有用过的数据应该是无用的，内存满了就优先删除那些很久没有用过的数据。 框架要求put和get的时间复杂度都是O(1)，因此这个数据结构必须满足的条件： 必须有时序，以区分最近使用和久未使用的数据，当容量满了之后要删除最久未使用的那个元素腾位置 要在cache中快速找某个key是否已经存在并得到对应的val 每次访问cache中的某个key，需要将这个元素变为最近使用的 哈希表：查找快，数据无固定顺序 链表：有顺序，插入删除快，查找慢 以上两者结合，形成新的数据结构：哈希链表LinkedHashMap LRU缓存算法的核心数据结构就是哈希链表、双向链表和哈希表的结合体 双链表结点12345678class Node{ public int key, val; public Node next, prev; public Node(int k, int v){ this.key = k; this.val = v; }} 双链表使用双向链表是因为我们需要删除操作，删除一个结点不光要得到该结点本身的指针，还要操作其前驱结点的指针，双向链表才能支持直接查找前驱，保证操作的诗句复杂度O(1) 123456789101112131415161718192021222324252627282930313233343536373839404142434445class DoubleList{ //头尾虚结点 private Node head, tail; //链表元素数 private int size; public DoubleList(){ //初始化双向链表的数据 head = new Node(0,0); tail = new Node(0,0); head.next = tail; tail.prev = head; size = 0; } //在链表尾部添加结点x 时间O(1) public void addLast(Node x){ x.prev = tail.prev; x.next = tail; tail.prev.next = x; tail.prev = x; size++; } //删除链表中x结点(x一定存在) //由于是双链表且给的目标Node结点，时间O(1) public void remove(Node x){ x.prev.next = x.next; x.next.prev = x.prev; size--; } //删除链表中的第一个结点 并返回该结点 时间O(1) public Node removeFirst(){ if(head.next == tail) return null; Node first = head.next; remove(first); return first; } //返回链表长度 时间O(1) public int size(){ return size; }} 哈希双链表1234567891011121314class LRUCache{ //key -&gt; node(key, val) private HashMap&lt;Integer, Node&gt; map; // node(k1, v1) &lt;-&gt; node (k2, v2) private DoubleList cache; //最大容量 private int cap; public LRUCache(int capacity){ this.cap = capacity; map = new HashMap&lt;&gt;(); cache = new DoubleList(); }} 因为要同时维护一个双链表cache和一个哈希表map，所以在这两种数据结构上提供一层抽象API，其实就是尽量让LRU主方法get和put避免直接操作到map和cache。 1234567891011121314151617181920212223242526272829303132333435//将某个key提升为最近使用的private void makeRecently(int key){ Node x = map.get(key); //先从链表中删除这个结点 cache.remove(x); //重新插到队尾 cache.addLast(x);}//添加最近使用的元素private void addRecently(int key, int val){ Node x = new Node(key, val); //链表尾部就是最近使用的元素 cache.addLast(x); //在map中添加key的映射 map.put(key,x);}//删除一个keyprivate void deleteKey(int key){ Node x = map.get(key); //从链表中删除 cache.remove(x); //从map中删除 map.remove(key);}//删除很久没使用的元素private void removeLeastRecently(){ //链表头部的第一个元素就是很久没用的 Node deleteNode = cache.removeFirst(); //别忘了从map中删除key int deleteKey = deleteNode.key; map.remove(deleteKey);} 实现get方法 1234567public int get(int key){ if(!map.containsKey(key)) return -1; //将该数据提升为最近使用的 makeRecently(key); return map.get(key).val;} 实现put方法 1234567891011121314public void put(int key, int val){ if(map.containsKey(key)){ // 删除旧数据 deleteKey(key); addRecently(key, val); //新插入数据为最近使用数据 return; } if(cap == cache.size()){ //删除最久未使用的元素 removeLeastRecently(); } //添加为最近使用的元素 addRecently(key, val);} Java内置哈希链表1234567891011121314151617181920212223242526272829303132333435363738394041class LRUCache { int cap; LinkedHashMap&lt;Integer, Integer&gt; cache = new LinkedHashMap&lt;&gt;(); public LRUCache(int capacity) { this.cap = capacity; } public int get(int key) { if(!cache.containsKey(key)){ return -1; } makeRecently(key); return cache.get(key); } public void put(int key, int value) { if(cache.containsKey(key)){ cache.put(key, value); makeRecently(key); return; } if(cache.size() &gt;= this.cap){ int oldestKey = cache.keySet().iterator().next(); cache.remove(oldestKey); } cache.put(key, value); } private void makeRecently(int key){ int val = cache.get(key); cache.remove(key); cache.put(key, val); }}/** * Your LRUCache object will be instantiated and called as such: * LRUCache obj = new LRUCache(capacity); * int param_1 = obj.get(key); * obj.put(key,value); */ LFU算法题目460 LFU Cache Hard 应用LRU的核心数据结构是使用哈希链表LinkedHashMap，首先借助链表的有序性使得链表元素维持插入顺序，然后借助哈希映射的快速访问能力在O(1)时间访问链表任意元素。 LFU相当于是把数据按照访问频次进行排序。如果多个数据拥有相同的访问频次，就要删除最早插入的那个数据。 框架思路分析LFU算法逻辑，需要实现： 调用get(key)，要返回该key对应的val 只要用get或者put方法访问一次某个key，该key的freq就要加一 如果在容量满了的时候进行插入，就要将freq最小的key删除，如果最小的freq对应多个key，则删除其中最旧的一个。 希望在O(1)时间内实现需求 实现所需的数据结构： 使用HashMap存储key到val的映射，可以快速计算 1HashMap&lt;Integer, Integer&gt; keyToVal; 使用一个HashMap存储key到freq的映射 1HashMap&lt;Integer, Integer&gt; keyToFreq; 这个需求对应LFU核心算法 用freq到key的映射，找到freq最小的key 将freq最小的key删除，快速得到当前所有key最小的freq是多少。要在O(1)实现，就不能遍历一遍，要用一个遍历minFreq来记录当前最小的freq 可以有多个key对应相同的freq，所以要让一个freq对应一个key列表 freq对应的key列表要存在时序，方便快速查找和删除最旧的key 希望可以快速删除key列表中的任何一个key，如果频次为freq的某个key被访问，那么频次就会变成freq+1，就要从freq对应的key列表中删除，加到freq+1对应的key列表中 LFU基本数据结构LinkedHashSet：链表和哈希集合的结合体。可以满足3.3 3.4 3.5要求 LinkedList：可以满足3.3 3.4需求 1234567891011121314151617181920212223class LFUCache{ //key--&gt;val KV 表 HashMap&lt;Integer, Integer&gt; k2v; //key--&gt;freq KF表 HashMap&lt;Integer, Integer&gt; k2f; //freq --&gt; key FK表 HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; f2k; //记录最小频次 int minFreq; //记录LFU缓存的最大容量 int cap; public LFUCache(int capacity){ k2v = new HashMap&lt;&gt;(); k2f = new HashMap&lt;&gt;(); f2k = new HashMap&lt;&gt;(); this.cap = capacity; this.minFreq = 0; } public int get(int key){} public void put(int key, int val){}} 最终代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596class LFUCache { // key 到 val 的映射，我们后文称为 KV 表 HashMap&lt;Integer, Integer&gt; keyToVal; // key 到 freq 的映射，我们后文称为 KF 表 HashMap&lt;Integer, Integer&gt; keyToFreq; // freq 到 key 列表的映射，我们后文称为 FK 表 HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; freqToKeys; // 记录最小的频次 int minFreq; // 记录 LFU 缓存的最大容量 int cap; public LFUCache(int capacity) { keyToVal = new HashMap&lt;&gt;(); keyToFreq = new HashMap&lt;&gt;(); freqToKeys = new HashMap&lt;&gt;(); this.cap = capacity; this.minFreq = 0; } public int get(int key) { if (!keyToVal.containsKey(key)) { return -1; } // 增加 key 对应的 freq increaseFreq(key); return keyToVal.get(key); } public void put(int key, int val) { if (this.cap &lt;= 0) return; /* 若 key 已存在，修改对应的 val 即可 */ if (keyToVal.containsKey(key)) { keyToVal.put(key, val); // key 对应的 freq 加一 increaseFreq(key); return; } /* key 不存在，需要插入 */ /* 容量已满的话需要淘汰一个 freq 最小的 key */ if (this.cap &lt;= keyToVal.size()) { removeMinFreqKey(); } /* 插入 key 和 val，对应的 freq 为 1 */ // 插入 KV 表 keyToVal.put(key, val); // 插入 KF 表 keyToFreq.put(key, 1); // 插入 FK 表 freqToKeys.putIfAbsent(1, new LinkedHashSet&lt;&gt;()); freqToKeys.get(1).add(key); // 插入新 key 后最小的 freq 肯定是 1 this.minFreq = 1; } private void increaseFreq(int key) { int freq = keyToFreq.get(key); /* 更新 KF 表 */ keyToFreq.put(key, freq + 1); /* 更新 FK 表 */ // 将 key 从 freq 对应的列表中删除 freqToKeys.get(freq).remove(key); // 将 key 加入 freq + 1 对应的列表中 freqToKeys.putIfAbsent(freq + 1, new LinkedHashSet&lt;&gt;()); freqToKeys.get(freq + 1).add(key); // 如果 freq 对应的列表空了，移除这个 freq if (freqToKeys.get(freq).isEmpty()) { freqToKeys.remove(freq); // 如果这个 freq 恰好是 minFreq，更新 minFreq if (freq == this.minFreq) { this.minFreq++; } } } private void removeMinFreqKey() { // freq 最小的 key 列表 LinkedHashSet&lt;Integer&gt; keyList = freqToKeys.get(this.minFreq); // 其中最先被插入的那个 key 就是该被淘汰的 key int deletedKey = keyList.iterator().next(); /* 更新 FK 表 */ keyList.remove(deletedKey); if (keyList.isEmpty()) { freqToKeys.remove(this.minFreq); // 问：这里需要更新 minFreq 的值吗？ } /* 更新 KV 表 */ keyToVal.remove(deletedKey); /* 更新 KF 表 */ keyToFreq.remove(deletedKey); }} 常数时间删除/查找数组中任意元素题目380 Insert Delete GetRandom O(1) Medium 710 Random Pick with Blacklist Hard 应用技巧在于如何结合哈希表和数组，使得数组的删除操作也变成O(1) 框架对于插入、删除、查找这几个操作，哪种数据结构的时间复杂度是O(1)？ HashSet。哈希集合的底层原理是一个大数组，把元素通过哈希函数映射到一个索引上，如果用拉链法解决哈希冲突，那这个索引可能连着一个链表或红黑树。 哈希链表LinkedHashSet， 给HashSet增加了有序性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class RandomizedSet { private ArrayList&lt;Integer&gt; values; private Map&lt;Integer, Integer&gt; valueToIndexMap; public RandomizedSet() { values = new ArrayList&lt;&gt;(); valueToIndexMap = new HashMap&lt;&gt;(); } public boolean insert(int val) { if(valueToIndexMap.containsKey(val)) { return false; } valueToIndexMap.put(val, values.size()); values.add(val); return true; } public boolean remove(int val) { if(!valueToIndexMap.containsKey(val)) { return false; } // get last element value and index int lastElementIndex = values.size() - 1; int lastElementValue = values.get(lastElementIndex); // find to remove index int toRemoveIndex = valueToIndexMap.get(val); // copy last element to removing element values.set(toRemoveIndex, lastElementValue); // remove last element values.remove(lastElementIndex); // update map valueToIndexMap.put(lastElementValue, toRemoveIndex); valueToIndexMap.remove(val); return true; } public int getRandom() { int index = new Random().nextInt(values.size()); return values.get(index); }} 求中位数题目295 Find Median from Data Stream Hard 思路核心思路是使用两个优先级队列 PriorityQueue对元素采用的是堆排序，头是按指定排序方式的最小元素。堆排序只能保证根是最大（最小），整个堆并不是有序的。方法iterator()中提供的迭代器可能只是对整个数组的依次遍历。也就只能保证数组的第一个元素是最小的。 框架1234567891011121314151617181920212223242526272829303132333435363738394041class MedianFinder { private PriorityQueue&lt;Integer&gt; large; private PriorityQueue&lt;Integer&gt; small; public MedianFinder() { //小顶堆 large = new PriorityQueue&lt;&gt;(); //大顶堆 small = new PriorityQueue&lt;&gt;((a,b)-&gt; (b-a)); } public void addNum(int num) { if(small.size() &gt;= large.size()){ small.offer(num); large.offer(small.poll()); }else{ large.offer(num); small.offer(large.poll()); } } public double findMedian() { //如果元素不一样多，多的那个堆的堆顶元素就是中位数 if(large.size() &lt; small.size()){ return small.peek(); }else if(large.size() &gt; small.size()){ return large.peek(); } //如果元素一样多，两个堆堆顶元素的平均数是中位数 return (large.peek() + small.peek())/2.0; }}/** * Your MedianFinder object will be instantiated and called as such: * MedianFinder obj = new MedianFinder(); * obj.addNum(num); * double param_2 = obj.findMedian(); */ 实现计算器题目224 Basic Calculator hard 227 Basic Calculator II medium 772 lock 思路字符串转整数123456string s = '458';int n = 0;for(int i = 0; i &lt; s.size(); i++){ char c = s[i]; n = 10*n + (c-'0');} 因为c是一个ASCII码，如果不加括号就先加后减，可能会整型溢出 加减法例子： 1-12+3 变成 +1 -12 +3 把运算符和数字组合成一对，变成3队，+1 -12 +3 然后转化成数字，放到一个栈中 将栈中所有数字求和 12345678910111213141516171819202122232425262728293031int calculate(string s){ stack&lt;int&gt; stk; int num = 0; //记录num前的符号，初始为+ char sign = '+'; for(int i = 0; i &lt; s.size(); i++){ char c = s.charAt(i); //如果是数字 连续读取到num if(isdigit(c)) num = 10*num + (c -'0'); //如果不是数字 就是遇到了下一个符号 //之前的数字和符号就要放在栈里面 if(!isdigit(c) || i == s.size() -1){ switch(sign){ case '+': stk.push(num); break; case '-': stk.push(-num); break; } //更新符号为当前符号，数字清零 sign = c; num = 0; } } //将栈中所有结果求和就是答案 int res = 0; while(!stk.isEmpty()){ res += stk.top(); stk.pop(); }} 乘除法例子：2-3*4+5 核心思路：把字符串分解成符号和数字的组合 (!isdigit(c) &amp;&amp; c!= ' ') 是为了不想让空格进入这个if 12345678910111213141516171819202122232425262728for(int i = 0; i &lt; s.size(); i++){ char c = s.charAt(i); if(isdigit(c)) num = 10 * num +(c-'0'); if((!isdigit(c) &amp;&amp; c!= ' ') || i == s.size() - 1){ switch(sign){ int pre; case '+': stk.push(num); break; case '-': stk.push(-num); break; //只用拿出前一个数字做对应运算即可 case '*': pre = stk.top(); stk.pop(); stk.push(pre * num); break; case '/': pre = stk.pop(); stk.pop(); stk.push(pre/num); break; } //更新符号为当前符号，数字清零 sign = c; num = 0; }} 处理括号1234567891011121314151617181920212223242526272829public int calculate(String s) { Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int sum = 0; int sign = 1; for(int i=0; i&lt;s.length(); i++) { char ch = s.charAt(i); if(ch == ' ') continue; if(ch == '-' || ch == '+') { sign = ch == '-' ? -1 : 1; } else if(ch == '(') { stack.push(sum); stack.push(sign); sum = 0; sign = 1; } else if(!stack.isEmpty() &amp;&amp; ch == ')') { sum = stack.pop() * sum; sum += stack.pop(); } else { int number = 0; while(i &lt; s.length() &amp;&amp; Character.isDigit(s.charAt(i))) { number *=10; number += s.charAt(i++) - '0'; } sum += sign * number; i--; } } return sum; }","link":"/2022/04/20/1.3%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/"},{"title":"2.1 二叉树","text":"Preface二叉树非常重要，是BFS, DFS, 回溯算法，动态规划，分治算法，图论算法的衍生。 这部分主要讲解二叉树的遍历、构造、序列化和反序列化、排序。 二叉树（纲领篇）二叉树的思维模式分2类： 是否可以通过遍历一遍二叉树得到答案？如果可以用一个traverse函数配合外部变量来实现，这叫【遍历】的思维模式 是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫【分解问题】的四诶模式 无论哪种思维模式，需要思考： 如果单独抽出一个二叉树结点，他要做什么事情？需要在什么时候（前/中/后序位置）做？其他结点不需要担心，递归函数会帮你在所有结点上执行相同的操作。 各种遍历 前序遍历：1 2 4 5 7 8 3 6 中序遍历：4 2 7 5 8 1 3 6 后序遍历：4 7 8 5 2 6 3 1 层次遍历：1 2 3 4 5 6 7 8 题目104 Maximum Depth of Binary Tree Easy 543 Diameter of Binary Tree Easy 144 Binary Tree Preorder Traversal Easy 二叉树的重要性 快速排序就是一个二叉树的前序遍历 归并排序就是二叉树的后序遍历 快速排序【逻辑】如果要对nums[l0..hi]排序，先找一个分界点p，通过交换元素使得nums[l0..p-1]都小于等于nums[p]，且nums[p+1...hi]都大于nums[p]，然后递归地去nums[l0..p-1]和nums[p+1..hi]中寻找新的分界点，最后整个数组就被排序了。 【框架】 12345678void sort(int[] nums, int lo, int hi){ //前序遍历位置 //通过交换元素构建分界点p int p = partition(nums, lo, hi); sort(nums, lo, p-1); sort(nums, p+1, hi);} 先构造分界点，然后去左右子数组构造分界点，就像前序遍历 归并排序【逻辑】要对nums[lo..hi]排序，我们要先对nums[lo..mid]排序，再对nums[mid+1...hi]排序，最后把这两个有序的子数组合并，整个数组就排好序了 【框架】 123456789101112//定义：排序nums[lo..hi]void sort(int[] nums, int lo, int hi){ int mid = (lo+hi)/2; //排序 nums[lo..mid] sort(nums, lo, mid); //排序 nums[mid+1, hi] sort(nums, mid+1, hi); //后序位置 //合并nums[lo..mid] 和 nums[mid+1..hi] merge(nums, lo, mid, hi);} 先对左右子数组排序，然后合并（类似合并有序链表），这就是二叉树的后序遍历框架。 另外，这也是所谓的分治算法。 二叉树的前中后序二叉树的遍历框架123456789void traverse(TreeNode root){ if(root == null) return; //前序 traverse(root.left); //中序 traverse(root.right); //后序} traverse实际就是一个能够遍历二叉树所有结点的函数，本质和遍历数组或链表没有区别 1234567891011121314151617181920212223242526272829303132//迭代遍历数组void traverse(int[] arr){ for(int i = 0; i &lt; arr.length; i++){ }}//递归遍历数组void traverse(int[] arr, int i){ if(i == arr.length) return; //前序位置 traverse(arr, i+1); //后序位置}//迭代遍历单链表void traverse(ListNode head){ for(ListNode p = head; p != null; p = p.next){ }}//递归遍历单链表void traverse(ListNode head){ if(head == null){ return; } //前序 traverse(head.next); //后序} 二叉树无非就是二叉链表，由于没有办法简单改写成迭代形式，所以一般二叉树的遍历框架都是指递归 只要是递归的遍历，都可以有前序和后序，分别在递归之前和之后。 前序位置就是刚进入一个结点的时候，后序就是即将离开一个结点的时候。 前中后序是遍历二叉树过程中处理每一个结点的三个特殊时间点： 前序位置的代码在刚刚进入一个二叉树结点时执行 后序位置的代码在将要离开一个二叉树结点时执行 中序位置的代码在一个二叉树接地那左子树都遍历完，即将开始遍历右子树的时候执行 所以多叉树没有中序位置，因为二叉树的每个结点只会进行唯一一次左子树切换右子树，而多叉树可能有很多子节点，会多次切换子树去遍历，所以没有【唯一】的中序遍历位置 两种解题思路二叉树的递归可以分成两类： 遍历一遍二叉树得出答案–》回溯算法核心框架 分解问题计算出答案–》动态规划核心框架 题目：104 二叉树的最大深度 遍历算法1234567891011121314151617181920212223242526//记录最大深度int res = 0;//记录遍历到的节点的深度int depth = 0;//主函数int maxDepth(TreeNode root){ traverse(root); return res;}//二叉树遍历框架void traverse(TreeNode root){ if(root == null){ //到达叶子结点，更新最大深度 res = Math.max(res, depth); return; } //前序位置 depth++; traverse(root.left); traverse(root.right); //后序位置 depth--;} 动态规划二叉树的最大深度可以通过子树的最大高度推导出来，这就是分解问题计算答案的思路 123456789101112//定义：输入根结点，返回这棵树的最大深度int maxDepth(TreeNode root){ if(root == null) return 0; //利用定义 计算左右子树的最大深度 int leftmax = maxDepth(root.left); int rightmax = maxDepth(root.right); //整棵树的最大深度=左右子树的最大深度s取最值 //然后加上根结点自己 int res = Math.max(leftmax, rightmax) + 1; return res;} 前序遍历遍历1234567891011121314151617List&lt;Integer&gt; res = new LinkedList&lt;&gt;();//返回前序遍历结果List&lt;Integer&gt; preorderTraverse(TreeNode root){ traverse(root); return res;}//二叉树遍历函数void traverse(TreeNode root){ if(root == null) return; //前序位置 res.add(root.val); traverse(root.left); traverse(root.right);} 分解123456789101112List&lt;Integer&gt; preorderTraverse(TreeNode root){ List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); if(root == null) return res; //前序遍历的结果 res.add(root.val); //利用函数定义，后面接着左子树的前序遍历结果 res.addAll(preorderTraverse(root.left)); //利用函数定义，最后接着右子树的前序遍历结果 res.addAll(preorderTraverse(root.right)); return res;} 中序和后序遍历也是类似的，只要把add(root.val)放在中序和后序对应的位置就好 但是这个算法的不知道不好把控，比较依赖语言的特性。Java的ArrayList还是LinkedList，addAll方法的复杂度都是O(N)，所以总体的最坏时间复杂度会达到O(N2)，除非自己实现一个复杂度O(1)的addAll方法，底层用链表的话并不是不可能。 后序位置的特殊之处【题目】 543 Diameter of Binary Tree Easy 366 find-leaves-of-binary-tree medium lock 124 Binary Tree Maximum Path Sum Hard 中序位置主要用在BST场景，可以把BST的中序遍历认为是遍历有序数组 前序位置本身没什么特别，很多题都是在前序位置写代码，实际上是因为我们习惯把那些对前中后序不敏感的代码写在前序位置罢了。 后序位置的代码是自底向上执行，前序位置的代码是自顶向下，说明前序位置的代码只能从函数参数中获取父结点传来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据 如果把根结点看成第一层，打印每个结点所在的层数 在第几层，从根结点遍历过来的过程就能顺带记录 1234567891011//二叉树遍历函数void traverse(TreeNode root, int level){ if(root == null) return; print(&quot;结点 %s 在第 %d 层&quot;, root, level); traverse(root.left, level+1); traverse(root.right, level+1);}//调用traverse(root, 1); 打印每个结点的左右子树各有多少结点 需要遍历完子树才能数清楚 12345678910//定义：输入一颗二叉树，返回这棵二叉树的节点总数int count(TreeNode root){ if(root == null) return 0; int l = count(root.left); int r = count(root.right); //后序位置 printf(&quot;结点 %s 的左子树有 %d 个结点，右子树有 %d 个结点&quot;, root, l, r); return l + r + 1;} 一旦发现题目和子树有关，大概率要给函数设置合理的定理和返回值，在后序位置写代码 层次遍历二叉树题型主要是用来培养递归思维的，层次遍历属于迭代遍历。 框架123456789101112131415161718192021//输入一棵二叉树的根结点，层次遍历这棵二叉树void levelTraverse(TreeNode root){ if(root == null) return; Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.offer(root); //从上到下遍历二叉树每一层 while(!q.isEmpty()){ int sz = q.size(); //从左到右遍历每一层的每个结点 for(int i = 0; i &lt; sz; i++){ TreeNode cur = q.poll(); //把下一层结点放入队列 if(cur.left != null) q.offer(cur.left); if(cur.right != null) q.offer(cur.right); } }} 应用BFS算法框架就是从二叉树的层次遍历扩展出来的，常用于求无权图的最短路径问题。 当题目不需要记录层数（步数）时，可以去掉上述框架中的for循环，比如Dijkstra算法中计算加权图的最短路径问题。 有些很明显需要用层次遍历的二叉树题目，也可以用递归遍历去解决，而且技巧性会更强。 题目515 Find Largest Value in Each Tree Row medium 这题我用的层次遍历写的，但是思路里面还提供了DFS的方法（不过我还没看） 二叉树（思路篇）题目226 Invert Binary Tree Easy 114 Flatten Binary Tree to Linked List medium 116 Populating Next Right Pointers in Each Node medium 框架三叉树12345678910111213141516171819202122232425class Solution { // 主函数 public Node connect(Node root) { if (root == null) return null; // 遍历「三叉树」，连接相邻节点 traverse(root.left, root.right); return root; } // 三叉树遍历框架 void traverse(Node node1, Node node2) { if (node1 == null || node2 == null) { return; } /**** 前序位置 ****/ // 将传入的两个节点穿起来 node1.next = node2; // 连接相同父节点的两个子节点 traverse(node1.left, node1.right); traverse(node2.left, node2.right); // 连接跨越父节点的两个子节点 traverse(node1.right, node2.left); }} 二叉树（构造篇）题目654 Maximum Binary Tree medium 105 Construct Binary Tree from Preorder and Inorder Traversal medium 106 Construct Binary Tree from Inorder and Postorder Traversal medium 889 Construct Binary Tree from Preorder and Postorder Traversal medium 思路二叉树的构造问题一般都是使用【分解问题】的思路：构造整棵树=根结点+构造左子树+构造右子树 前序和中序构造树1234567891011121314151617181920212223242526272829303132333435363738394041class Solution { // 存储 inorder 中值到索引的映射 HashMap&lt;Integer, Integer&gt; valToIndex = new HashMap&lt;&gt;(); public TreeNode buildTree(int[] preorder, int[] inorder) { for (int i = 0; i &lt; inorder.length; i++) { valToIndex.put(inorder[i], i); } return build(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1); } /* 定义：前序遍历数组为 preorder[preStart..preEnd]， 中序遍历数组为 inorder[inStart..inEnd]， 构造这个二叉树并返回该二叉树的根节点 */ TreeNode build(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd) { if (preStart &gt; preEnd) { return null; } // root 节点对应的值就是前序遍历数组的第一个元素 int rootVal = preorder[preStart]; // rootVal 在中序遍历数组中的索引 int index = valToIndex.get(rootVal); int leftSize = index - inStart; // 先构造出当前根节点 TreeNode root = new TreeNode(rootVal); // 递归构造左右子树 root.left = build(preorder, preStart + 1, preStart + leftSize, inorder, inStart, index - 1); root.right = build(preorder, preStart + leftSize + 1, preEnd, inorder, index + 1, inEnd); return root; }} 中序和后序构造二叉树12345678910111213141516171819202122232425262728293031323334353637383940class Solution { // 存储 inorder 中值到索引的映射 HashMap&lt;Integer, Integer&gt; valToIndex = new HashMap&lt;&gt;(); public TreeNode buildTree(int[] inorder, int[] postorder) { for (int i = 0; i &lt; inorder.length; i++) { valToIndex.put(inorder[i], i); } return build(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1); } /* 定义： 中序遍历数组为 inorder[inStart..inEnd]， 后序遍历数组为 postorder[postStart..postEnd]， 构造这个二叉树并返回该二叉树的根节点 */ TreeNode build(int[] inorder, int inStart, int inEnd, int[] postorder, int postStart, int postEnd) { if (inStart &gt; inEnd) { return null; } // root 节点对应的值就是后序遍历数组的最后一个元素 int rootVal = postorder[postEnd]; // rootVal 在中序遍历数组中的索引 int index = valToIndex.get(rootVal); // 左子树的节点个数 int leftSize = index - inStart; TreeNode root = new TreeNode(rootVal); // 递归构造左右子树 root.left = build(inorder, inStart, index - 1, postorder, postStart, postStart + leftSize - 1); root.right = build(inorder, index + 1, inEnd, postorder, postStart + leftSize, postEnd - 1); return root; }} 后序和前序构造二叉树通过前序后序遍历结果无法确定原始二叉树，如果有多种可能的还原结果，可以返回任何一种。 但是仅通过后序和前序，可以确定根结点，但无法确切的知道左右子树有哪些结点。 【思路】 把前序遍历的第一个元素或者后序遍历的最后一个元素作为根结点的值 把前序遍历的第二个元素作为左子树的根结点的值 在后序遍历结果中寻找左子树根结点的值，从而确定左子树的索引边界，进而确定右子树的索引边界，递归构造左右子树 【不唯一的原因】假设前序遍历的第二个元素是左子树的根结点，但左子树有可能是空指针。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution { // 存储 postorder 中值到索引的映射 HashMap&lt;Integer, Integer&gt; valToIndex = new HashMap&lt;&gt;(); public TreeNode constructFromPrePost(int[] preorder, int[] postorder) { for (int i = 0; i &lt; postorder.length; i++) { valToIndex.put(postorder[i], i); } return build(preorder, 0, preorder.length - 1, postorder, 0, postorder.length - 1); } // 定义：根据 preorder[preStart..preEnd] 和 postorder[postStart..postEnd] // 构建二叉树，并返回根节点。 TreeNode build(int[] preorder, int preStart, int preEnd, int[] postorder, int postStart, int postEnd) { if (preStart &gt; preEnd) { return null; } if (preStart == preEnd) { return new TreeNode(preorder[preStart]); } // root 节点对应的值就是前序遍历数组的第一个元素 int rootVal = preorder[preStart]; // root.left 的值是前序遍历第二个元素 // 通过前序和后序遍历构造二叉树的关键在于通过左子树的根节点 // 确定 preorder 和 postorder 中左右子树的元素区间 int leftRootVal = preorder[preStart + 1]; // leftRootVal 在后序遍历数组中的索引 int index = valToIndex.get(leftRootVal); // 左子树的元素个数 int leftSize = index - postStart + 1; // 先构造出当前根节点 TreeNode root = new TreeNode(rootVal); // 递归构造左右子树 // 根据左子树的根节点索引和元素个数推导左右子树的索引边界 root.left = build(preorder, preStart + 1, preStart + leftSize, postorder, postStart, index); root.right = build(preorder, preStart + leftSize + 1, preEnd, postorder, index + 1, postEnd - 1); return root; }} 二叉树（序列化篇）用前序、中序、后序遍历的方法来序列化和反序列化二叉树，进一步会用迭代式的层级遍历来解决这个问题。 题目297 Serialize and Deserialize Binary Tree hard 应用Json运用非常广泛，比如经常将变成语言中的结构体序列化成json字符串，存入缓存或者通过网络发给远端服务，消费者接受JSON字符串然后进行反序列化，就可以得到原始数据。这就是序列化和反序列化的目的，以某种固定格式组织字符串，使得数据可以独立于变成语言。 前序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Codec { String SEP = &quot;,&quot;; String NULL = &quot;#&quot;; /* 主函数，将二叉树序列化为字符串 */ public String serialize(TreeNode root) { StringBuilder sb = new StringBuilder(); serialize(root, sb); return sb.toString(); } /* 辅助函数，将二叉树存入 StringBuilder */ void serialize(TreeNode root, StringBuilder sb) { if (root == null) { sb.append(NULL).append(SEP); return; } /******前序遍历位置******/ sb.append(root.val).append(SEP); /***********************/ serialize(root.left, sb); serialize(root.right, sb); } /* 主函数，将字符串反序列化为二叉树结构 */ public TreeNode deserialize(String data) { // 将字符串转化成列表 LinkedList&lt;String&gt; nodes = new LinkedList&lt;&gt;(); for (String s : data.split(SEP)) { nodes.addLast(s); } return deserialize(nodes); } /* 辅助函数，通过 nodes 列表构造二叉树 */ TreeNode deserialize(LinkedList&lt;String&gt; nodes) { if (nodes.isEmpty()) return null; /******前序遍历位置******/ // 列表最左侧就是根节点 String first = nodes.removeFirst(); if (first.equals(NULL)) return null; TreeNode root = new TreeNode(Integer.parseInt(first)); /***********************/ root.left = deserialize(nodes); root.right = deserialize(nodes); return root; }} 后序123456789101112131415161718192021222324252627282930313233343536373839public class Codec { String sep = &quot;,&quot;; String isnull = &quot;#&quot;; // Encodes a tree to a single string. public String serialize(TreeNode root) { StringBuilder sb = new StringBuilder(); serialize(root, sb); return sb.toString(); } void serialize(TreeNode root, StringBuilder sb){ if(root == null){ sb.append(isnull).append(sep); return; } serialize(root.left, sb); serialize(root.right, sb); sb.append(root.val).append(sep); } // Decodes your encoded data to tree. public TreeNode deserialize(String data) { LinkedList&lt;String&gt; nodes = new LinkedList&lt;&gt;(); for(String s: data.split(sep)){ nodes.add(s); } return deserialize(nodes); } TreeNode deserialize(LinkedList&lt;String&gt; nodes){ String first = nodes.removeLast(); if(first.equals(isnull)) return null; TreeNode root = new TreeNode(Integer.parseInt(first)); root.right = deserialize(nodes); root.left = deserialize(nodes); return root; }} 中序先说结论，中序遍历的方式行不通，因为无法实现反序列化方法deserialize。 12345678910111213/* 辅助函数，将二叉树存入 StringBuilder */void serialize(TreeNode root, StringBuilder sb) { if (root == null) { sb.append(NULL).append(SEP); return; } serialize(root.left, sb); /******* 中序位置 *******/ sb.append(root.val).append(SEP); /***********************/ serialize(root.right, sb);} 层次1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162String SEP = &quot;,&quot;;String NULL = &quot;#&quot;;/* 将二叉树序列化为字符串 */String serialize(TreeNode root) { if (root == null) return &quot;&quot;; StringBuilder sb = new StringBuilder(); // 初始化队列，将 root 加入队列 Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.offer(root); while (!q.isEmpty()) { TreeNode cur = q.poll(); /* 层级遍历代码位置 */ if (cur == null) { sb.append(NULL).append(SEP); continue; } sb.append(cur.val).append(SEP); /*****************/ q.offer(cur.left); q.offer(cur.right); } return sb.toString();}/* 将字符串反序列化为二叉树结构 */TreeNode deserialize(String data) { if (data.isEmpty()) return null; String[] nodes = data.split(SEP); // 第一个元素就是 root 的值 TreeNode root = new TreeNode(Integer.parseInt(nodes[0])); // 队列 q 记录父节点，将 root 加入队列 Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.offer(root); for (int i = 1; i &lt; nodes.length; ) { // 队列中存的都是父节点 TreeNode parent = q.poll(); // 父节点对应的左侧子节点的值 String left = nodes[i++]; if (!left.equals(NULL)) { parent.left = new TreeNode(Integer.parseInt(left)); q.offer(parent.left); } else { parent.left = null; } // 父节点对应的右侧子节点的值 String right = nodes[i++]; if (!right.equals(NULL)) { parent.right = new TreeNode(Integer.parseInt(right)); q.offer(parent.right); } else { parent.right = null; } } return root;} 二叉树（后序篇）题目652 Find Duplicate Subtrees medium 应用一旦发现题目和子树有关，大概率要给函数设置合理的定义和返回值，在后序位置写代码 代码你需要知道以下两点： 1、以我为根的这棵二叉树（子树）长啥样？ ​ 要知道以自己为根的子树长啥样，是不是得先知道我的左右子树长啥样，再加上自己，就构成了整棵子树的样子 2、以其他节点为根的子树都长啥样？ 借助一个外部数据结构，让每个节点把自己子树的序列化结果存进去，这样，对于每个节点，不就可以知道有没有其他节点的子树和自己重复了 这里用HashMap而不是HashSet因为，HashSet当有多个重复时利用constains(xx)会导致结果列表值重复。 1234567891011121314151617181920212223242526272829303132class Solution { // 记录所有子树以及出现的次数 HashMap&lt;String, Integer&gt; memo = new HashMap&lt;&gt;(); // 记录重复的子树根节点 LinkedList&lt;TreeNode&gt; res = new LinkedList&lt;&gt;(); /* 主函数 */ public List&lt;TreeNode&gt; findDuplicateSubtrees(TreeNode root) { traverse(root); return res; } String traverse(TreeNode root) { if (root == null) { return &quot;#&quot;; } String left = traverse(root.left); String right = traverse(root.right); String subTree = left + &quot;,&quot; + right + &quot;,&quot; + root.val; int freq = memo.getOrDefault(subTree, 0); // 多次重复也只会被加入结果集一次 if (freq == 1) { res.add(root); } // 给子树对应的出现次数加一 memo.put(subTree, freq + 1); return subTree; }} 归并排序题目912 Sort an Array medium 315 Count of Smaller Numbers After Self hard 493 Reverse Pairs hard 327 Count of Range Sum hard 思路所有的递归算法，本质上就是在遍历一棵（递归）树，然后在结点（前中后序位置）上执行代码。 所写的递归算法，本质上就是要告诉每个结点需要做什么。 归并排序就是把左半边数组排好序，再把右半边数组排好序，然后把两半数组合并 框架【复杂度】这个二叉树的高度是logN，其中每一层的元素个数就是原数组的长度N，所以总的时间复杂度就是O(NlogN) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Merge { // 用于辅助合并有序数组 private static int[] temp; public static void sort(int[] nums) { // 先给辅助数组开辟内存空间 temp = new int[nums.length]; // 排序整个数组（原地修改） sort(nums, 0, nums.length - 1); } // 定义：将子数组 nums[lo..hi] 进行排序 private static void sort(int[] nums, int lo, int hi) { if (lo == hi) { // 单个元素不用排序 return; } // 这样写是为了防止溢出，效果等同于 (hi + lo) / 2 int mid = lo + (hi - lo) / 2; // 先对左半部分数组 nums[lo..mid] 排序 sort(nums, lo, mid); // 再对右半部分数组 nums[mid+1..hi] 排序 sort(nums, mid + 1, hi); // 将两部分有序数组合并成一个有序数组 merge(nums, lo, mid, hi); } // 将 nums[lo..mid] 和 nums[mid+1..hi] 这两个有序数组合并成一个有序数组 private static void merge(int[] nums, int lo, int mid, int hi) { // 先把 nums[lo..hi] 复制到辅助数组中 // 以便合并后的结果能够直接存入 nums for (int i = lo; i &lt;= hi; i++) { temp[i] = nums[i]; } // 数组双指针技巧，合并两个有序数组 int i = lo, j = mid + 1; for (int p = lo; p &lt;= hi; p++) { if (i == mid + 1) { // 左半边数组已全部被合并 nums[p] = temp[j++]; } else if (j == hi + 1) { // 右半边数组已全部被合并 nums[p] = temp[i++]; } else if (temp[i] &gt; temp[j]) { nums[p] = temp[j++]; } else { nums[p] = temp[i++]; } } }} 327 Count of Range Sum下面是我写的，但是一直超时…… 看注释，发现bug了！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution { int cnt = 0; int low; int up; long[] tmp; public int countRangeSum(int[] nums, int lower, int upper) { long[] presum = new long[nums.length+1]; for(int i = 1; i &lt; presum.length; i++){ presum[i] = presum[i-1] + (long)nums[i-1]; } //[i..j] = presum[j] - presum[i-1]; low = lower; up = upper; tmp = new long[presum.length]; sort(presum, 0, presum.length-1); return cnt; } void sort(long[] presum, int l, int h){ if(l &gt;= h) return; int mid = l + (h - l)/2; sort(presum, l, mid); sort(presum, mid+1, h); merge(presum, l, mid, h); } void merge(long[] presum, int l, int mid, int h){ //后面发现是这里写错，一定要从l h不是0-len！ for(int i = l; i &lt;= h; i++){ tmp[i] = presum[i]; } int k = mid+1, s= mid+1; for(int p = l; p &lt;= mid; p++){ while(s &lt;= h &amp;&amp; tmp[s] - tmp[p] &lt; low){ s++; } while(k &lt;= h &amp;&amp; tmp[k] - tmp[p] &lt;= up){ k++; } cnt += k - s; } int i = l, j = mid+1; for(int p = l; p &lt;= h; p++){ if(i == mid + 1){ presum[p] = tmp[j++]; }else if(j == h + 1){ presum[p] = tmp[i++]; }else if(tmp[i] &gt; tmp[j]){ presum[p] = tmp[j++]; }else{ presum[p] = tmp[i++]; } } }}","link":"/2022/04/21/2.1%20%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"2022暑假阅读笔记","text":"前情提要这个人生中最后一个暑假（毕竟读研了可能就没真正意义的假期了，再加上疫情，所以就自己在家里看书、打游戏、睡觉、看电视。读的书是导师推荐的书单上面找的几本书，用微信读书看的，感谢科技！ 读了5本书：《把自己作为方法》、《千年金融史》、《天才为何成群地来》、《贫穷的本质：我们为什么摆脱不了贫穷》、《边城》，在此摘抄一些句子。 把自己作为方法北京访谈 我们现在跟年轻人谈话，让他坐下来讲一下他们班、他们学校的事，将清楚这个体系是怎样运转的，基本的权力结构是什么，主导意识是什么，每个人的动机是什么，能够分成几类，大部分人讲不出来。这其实是非常重要的一种训练。大家一定要对自己生活的小世界发生兴趣，有意识地用自己的语言把自己的生活讲出来，做一个独立的叙述——也不用分析，就是叙述。 所以有人说，中国开始现代化的象征之一，就是官僚退休不回家乡了。城市和农村之间的循环性的关系被打断了。告老不还乡，点出了中国的中心和边缘的关系、城市和农村的关系、知识分子和普通群众（主要是农民）的关系，在现代发生了什么变化。 距离感、怀疑心可能还是蛮重要的，否则去大学就很容易被卷入别人的话语里去。 （浙江村的研究）它让我看到，一个小型企业，与其说它是一个组织，还不如说它是一个网络。或者说，企业首先是一个亲属组织、社会组织，其次才是一个经济组织。 北大青年的焦虑 为什么苏东解体之后，东欧社会变得那么功利主义，大家都围着钱转？ 苏东解体之后，它就成了赤裸裸的资本主义，只有成功和失败的区别，没有可耻的成功和可荣的成功之间的区别，完全根据最后现金的获得量来衡量，哪怕是用可耻的方法获得了成功，也可以很自豪，甚至比正常的方法更值得骄傲，说明你聪明、大胆。 我妈妈回了一封信，我的印象比较深，她说他们年轻的时候什么都学苏联，现在什么都学西方，这是一个问题。 大部分地方院校的老师其实对自己身边的生活兴趣很小，看一下学术期刊上写什么文章，就往上套，主要目的是进入那个话语体系，而不是观察身边的世界。 青年很重要，不在于我们去回想自己的青年时光，而是用今天青年的眼光去拷问我们，让他们来“审判”我们，这样才能有更真的东西，我们才有机会反思自己。 当时万马齐喑，大家都很功利地在学习，第一年很不愉快。 1992年，讲座就开始多了，很多都是关于营销策划的。这种学生下海赚钱的事其实在1991年就有了，但在1992年一下子爆发出来，市场经济被认为是正统。各种文化现象也重新出来，比如新一轮“国学热”。 【第三位先生】Science Democracy Morality 道德不应该像帽子一样戴在我们头上，罩在我们生活中，今天的道德必须把帽子从头上摘下来，放在我们手上，我们要去观察它。如果一顶帽子戴在头上，我们是看不到它的，我们可以意识到它的存在，但不知道帽子是什么形状什么颜色，不知道道德从哪里来，糊里糊涂跟着它走，是盲目地跟从。如果要让别人去尊重这样的道德，那就是不道德。 研究浙江村 阅读功力跟年纪很有关系，必须在一定的年纪以一定的力度去阅读，才能达到那种能力。我就是在那样的年纪没有密集地读学术文章，所以大脑的这部分功能没有被很好地训练出来，到现在也是这样，我跟文字的关系比较隔膜，很难从文字里面得到兴奋感。 他们给我的熏陶很重要。他们不讲理论，只讲故事讲经历，讲见地，很直接，一刀插进去再提出来。 他说北大给你一个很重要的东西就是不怵，到了哪里都不怵。这个可能是对的。 理论不在于新不新，深不深，更不在于正确不正确，而是能不能形成沟通性。可沟通性非常重要，哪怕是一个浅显的理论，但它一下子调动起对方的思想，把对方转变成一个新的主体，那这个理论就是革命性的。 你可以看出他的fun，他不是根据大家说了什么而去设计这个项目，而是到垃圾场看见人家的房子这么干净，问这些具体的问题。 Fun的意思就是能够对事情本身发生很大的兴趣和热情，不需要外在的回报来刺激热情。 日本的教育也不太行，很强调工匠精神，强调执着、专注，也不太强调fun。 我们读书，理解人类社会的规律，都一定要和自己这个人发生关系，否则搞艺术就是为了美，好像是一个服务工作，去取悦人。大家要倒过来看，不要想着去取悦，想着自己怎么可以fun，即使很简单的服务行业，比如在饭店，如果认真去观察，也能很fun，像个小作家一样去看各色人等，每个人经过前台时有什么不一样，怎样跟他互动……如果给员工很大的自主性和空间，让他觉得自己不是机械的一部分，而是作为一个社会人在跟人打交道，也会有很多创新。 边缘与中心 平衡自己的历史来源和自己现在的行动，这是真正的英雄。真正的英雄不是改变世界，而是改变自己生活的每一天。 而且一旦进入中心之后，很多人就变质腐败，因为他们从来没有把自己是谁想清楚，存在就是为了进入中心，把生他养他的土地、和周围人的关系都放弃了，变成没有原则的人。 中国在事实上的连贯性很弱，也有很多的断裂，但每一个朝代都修前朝的历史，在历史书写上连贯性很强，所以就造成了很强的意识上的连贯性——我们是中国人，有这个这么一个单位。但在实际的生活逻辑上，其实有极大的断裂。 个人危机 为什么会去追求那种认可？就是因为没有小世界。如果我有自己真实的小世界，哪怕边缘，但比较强大，可以互相讨论，不用去找这样的认可。 不要怕边缘，或者知识不够，把自己的不够，天真真实地体现出来，就会很可爱，不要装腔作势。 全球化与逆全球化 这也是知识分子的修养，看到一个事不会轻易地兴奋，说我们城市化办得好，那就要去问，原来住在这的人去哪了，他们怎么想的，为什么其他国家那些人就没有被清理。老是反着问。反着问也不是故意挑刺，也是一种乐趣吧。我觉得这就是反思，反思不一定要咬着牙，有的时候跟道德一样，需要拿下来放在手里，这样捏捏那样捏捏，就进入这个事情内部去了。 用80年代来批判80年代 像鲁迅讲的，心里不禁起疑。起疑这两个字好可爱，我很喜欢这个词。 大家都觉得民粹主义意味着大众的兴起，但其实民粹的背后还是精英，又是精英内部新的斗争。 所谓理想主义首先就是一种超越，存在的价值就是对现状的超越，就是追求现在不存在的东西。 什么是批判 从认知科学的角度来说，音乐跟数学紧密地联系在一起，因为它超越文化超越语言，所以叔本华这些人都觉得音乐体现了人类大脑的某种内在结构。 他说，我是一个失败者，成为屌丝，并不是因为自己无能，而是社会如此不公，我认了，但我嘲讽你。如果在印度，低种姓的人不会称自己是屌丝，因为能够把自己叫作屌丝，其实是有能动、有力量、有批判性的。所以个人把自己定义为什么样的个体，背后都有一定的社会公共意识在里头。这里头可能就有正能量。 理解的学问 深刻是从网状知识结构中来的，而那种犬儒式投降式地回到自己的小世界，买完菜、做完饭，其他什么都不管，只是消极地用最小耗能法去应对，生命也可以维持下去，但就停止思考了。那就把生命的活的网变成了一个死的点。 牛津访谈访谈之前 社会科学要给普通人提供观察世界、为人处世的方法，不是通过简单的道德教化，而是通过分析，这是社会科学的一个重要功能。它不像自然科学，发现自然规律，问题就解决了，顺着规律走就可以。它可能是倒过来，社会科学告诉你，其实没有什么很强的规律，都在于自己怎么样去理解这个世界，怎么样主动地采取行动。可能会有很大的图景，但没有所谓的规律，因为一旦发现规律，那么一切到此为止，就不需要再去做工作了。它是通过科学的态度去证伪，去搜集材料，把事情搞清楚，但最后是要武装你，进一步去创造新的现实，去改变现实。 象征就是牢笼，奔向象征是奔向了文明，同时也奔向了牢笼。背后是一种非常野蛮的关系。 我们总体的社会环境，有很强的冲动要把人符号化、象征化，这个大学，那个名人，很多人都是抱着五颜六色的泡泡在漂。年轻人要有勇气去问：这是在干什么，这个大学好在哪儿，跟我有什么关系，名人不名人的，先看他在说什么，说的东西有没有趣，直截了当地去理解。 符号是靠大家撑着的，如果不撑它，符号就没有了。把符号化的东西消解掉，形成有机的小群体、横向的领导力，不要指望有父母亲式的任务给你保护。我们从小的教育符号化太重了，要摆脱那个，用比较自然的方式问问题，用有机的语言说话，这需要一段时间的培养。 牛津记忆 我觉得大学生在大学里的任务，不是树立norms（规范），而是树立exceptions（例外），你不是范例而是例外。我们的社会需要例外，你要代表这个社会去做例外。 我一想未名湖都是这些副省长在那里漫步，来充充电赏赏光，就觉得很没味道。 没有竞争压力了，大家最独特的才华才会体现出来。 聊天对我来讲就是继续的社会调查 整个社会科学就是学习培养主体性。主体性不是说“我很厉害”，“我很特殊”，完全不是这个意思；而是说我作为一个人在这个世界上，我和世界是什么关系，我看到了什么，哪怕我的看法不对，但是应该把自己怎么想的搞清楚。 人类学的圈子 事实上，政治是一个比较简单的东西，主要就是不同群体之间的利益分配，当然它具体的展示方式很丰富。但如果不讲人的位置和利益分配的过程，只讲弥散在日常生活里的权力关系，那到处都是，讲不清楚，于是就变得不够直接。 非虚构写作 我们都知道在萨特之后，存在先于本质，意思就是说你本质到底是一个什么样的人不是给定的，你的行为、你的存在，决定了你是什么样的人。没有人生出来就是妇女，是你在社会进程当中变成了妇女。 女性当然是在社会化的进程中被塑造成女性的，但是你也不能轻易地把自己去女性化。那个塑造你的时候和历史力量实在很强，远远强于任何个人的、短时间内的努力。穷人家的孩子当然也可能成为富人，但是光靠想着自己不认穷人这个命不是解决办法，而且我们知道这种想法导致了大量的心理和社会问题。 所以关键是要把自己所在的时候位置相透，女性的命、穷人的命为什么还这么难？在这个现实下，怎么去当一个女性、一个穷人，怎么和那个强大的社会和历史力量持续地较劲，不认输地较劲？ 学术不是天职 学术不是天职，还是工具，是我介入社会、介入世界的一种途径。 民族与民粹 艺术不完全是靠想象，艺术很具体，你对今天早上那一束阳光的感受，是很具体的，要把握那种感受，一定要把它做出来，通过雕塑或者画画，色彩的调配，物质性很强。夸夸其谈相当可怕，好像一种灵感让自己感动起来，但是飘过去了就什么都没有。 现在很多民族主义的情绪是把民族这条线给绝对化了，看不到历史上民族是怎么形成的，但是又拿起历史上的斗争和自己的狭隘的理解套起来，所以很多年轻人也就被绕进去了。 新加坡启蒙 新加坡这么小，但它有高度的智慧，small but smart，不断去观察别人，把自己嵌入，因为总是怕自己被别人抛弃。而“大“就总是从自己出发，觉得别人不能定义我，我要定义别人，不是去观察啊，而是去定义，动不动就反对这个宣扬那个，智慧程度反而慢慢降低了。 “盘根”式共同体 当年轻人背包旅行的时候，怎么样去看待那些让自己不适应的情况，通过对别人的观察，去理解，把自己问题化，重新定义现存的社会问题。 大学应该寻找例外 大学就是给你一个环境，让你在人生比较特殊的四五年当中去探索自己，探索这个世界，允许你犯错误，允许你做疯狂的探索，让你对事情产生理解，当然也学到了基本的知识和技术。 西方的教育和大学，在追求例外这一点上，现在依然是成功的吗？ 我觉得在一定程度上说是的。你可以说它很虚伪，因为到最后也是一个阶级再生产的过程。 当然在哲学意义上来说，人都是互为工具，什么时候被利用，什么时候利用别人，在每一个环节当中都是复杂的，这时候就需要一些基本原则，要看具体的情况怎么分析。 个人经验的问题化起源 个人经验的问题化起源就是对自己的不满意，讲来讲去都没有深度，不有趣，于是开始抱怨，抱怨体制、抱怨父母、抱怨童年，就开始问题化。但个人经验本身并不是那么重要，把个人经验问题化是一个重要方法。我们关心的是世界，不是自己，现在关键就是从哪里开始了解这个世界，同时也更好地了解自己，把个人自己的经历问题化，就是一个了解世界的具体的开始。 我对自己不满意，看自己的成长经历，同时也要看自己和这个世界的关系，别人怎么会想到这些事情而自己看不到，这样才能不断地看到很具体的世界。 新研究 再生产和学生的流动就很有关系，现在的英语教育、出国留学，不仅是简单的镀金，而是要改变人本身。家长们不仅仅是想让孩子读个洋学位好找工作，而是越来越觉得国内的教育不符合人性，把孩子的天性快乐搞没了，出国是为了保护“人”。这背后不是简单的理念问题。这么大的产业，最后是一个长期的社会问题。 共同理想 明明是一个纯粹的商业结构，大家却努力把利益关系转化成上下级关系，因为只有这样，商业利益才能得到更好的保证。 自我证明这个概念是个悖论。要证明自己其实就是没有自己，意思是说，要通过已经设定的原则和标准、别人的逻辑和流程来证明自己的存在，其实是取悦别人，把自己搞没有了。 乡绅作为方法 接受了西洋教育之后，我知道农民一定要生男孩子是不对的，但不能否定他们的感觉，所以要了解他们的生活安排，哪一块能动，哪一块只能靠时间解决。 温州访谈人的再生产 人的生产是说人怎么样被培养成一个生产的要素，而人的再生产就是人怎么样再生产自己，自己成为目标 为什么中国人在变富的同时追求所谓“早发早移”，也就是说，尽快赚钱然后尽早移民，很重要的原因就是移民并不是为了赚钱，而是为了“人的再生产“，为了更加稳定的可预期的未来，为了更好的子女的教育、更洁净的空气、更多的绿地，但赚钱还得在中国赚，因为这里的利润比西方还要高。 留学是把社会分化跨国化了。在一个国家内部的分化竞争到了尽头，必须要往外走。中国玩不转，就出国玩；父辈有钱，儿子就挣学历。空间上从国内转到国外，资本类型上要从有形的金融资源转变为文化和象征资本。文化象征资本对维持金融和经济资本的跨代增值非常重要。不平等的固化都是这样，从钱到名到身份，以及空间上的转移。 人的跨国流动，人的再生产，背后总是有这样的辩证关系。流动，加速的流动，不一定使生活变得更开放，反而可能加固了原本的不平等关系和这种意识形态、社会规范。 阶层流动的悖论 顶层的人为了保住顶层的资源，将资本向海外转移；中下层的人，比如农村或者小镇的人，也想到出国，去新加坡、日本打工，形成了横向纵向的交错关系；城市中层的，努力送孩子出国读书。 现在我们好像被绑架了，一定要更高更快更强，正是因为不太愿意进行激烈的再分配，已经获得的人还要获得更多，同时又要把下面的人也提上去，这个确实很难，今后可能还是要慢慢走向再分配的思路。 作为中介的人类学 我们大部分人写文章是为了让其他学者认可，而不是让你的研究调查对象认可。 再谈乡绅 所谓只是就是对世界上发生了什么事有根有据的了解，从这里开始，去观察，去沉淀，慢慢沉淀出底气。 与其说是一个搜集材料的场合，不如说是一次学习。你要去理解每个人的合理性在哪里。我觉得这种社交比圈子更有趣，虽然有点不舒服，但有意思，因为它给你的刺激更大。","link":"/2022/08/20/2022%E6%9A%91%E5%81%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"title":"2.2 二叉搜索树","text":"PrefaceBinary Search Tree, BST是一种特殊的二叉树，你只要记住他的两个主要特点： 左小右大，每个结点的左子树都比当前结点的值小，右子树都比当前结点的值大 中序遍历结果是有序的 这部分主要讲解BST的遍历、搜索、判断合法性、插入、删除、构造、后序遍历、快速排序。 二叉搜索树的特性二叉搜索树并不算复杂，但可以算是数据结构领域的半壁江山，直接基于BST的数据结构有AVL树、红黑树，拥有了自平衡性，可以提供logN级别的增删改查效率；还有B+树，线段树等结构都是基于BST思想来设计的。 BST的中序遍历结构是有序的（升序） 题目230 Kth Smallest Element in a BST medium 538 Convert BST to Greater Tree medium 1038 Binary Search Tree to Greater Sum Tree medium 【1038 和 538 是一样的题】 框架遍历时间复杂度：O(N) 增删改查复杂度：O(logN) 遍历BST1234567void traverse(TreeNode root){ if(root == null) return; traverse(root.left); print(root.val); traverse(root.right);} 为了降低时间复杂度，可以在TreeNode字段中增加以该结点为根的树的节点总数size，这样每个结点node就可以通过自己的左结点推断出node的排名，进行对数级算法。 基本操作题目450 Delete Node in a BST medium 701 Insert into a Binary Search Tree medium 700 Search in a Binary Search Tree easy 98 Validate Binary Search Tree medium 框架普通二叉树搜索12345678TreeNode search(TreeNode root, int target){ if(root == null) return null; if(root.val == target) return root; //当前结点没找到就递归去左右子树找 TreeNode left = search(root.left, target); TreeNode right = search(root.right, target); return left != null ? left : right;} 二叉树搜索树搜索12345678910void BST(TreeNode root, int target){ if(root.val == target) //找到目标做什么 if(root.val &lt; target){ BST(root.right, target); } if(root.val &gt; target){ BST(root.left, target); }} 合法性判断12345678910111213141516boolean isValidBST(TreeNode root){ return isValidBST(root, null, null);}//限定以root为根的子树结点必须满足 max.val &gt; root.val &gt; min.valboolean isValidBST(TreeNode root, TreeNode min, TreeNode max){ //base case if(root == null) return true; //判断是否符合限制 if(min != null &amp;&amp; root.val &lt;= min.val) return false; if(max != null &amp;&amp; root.val &gt;= max.val) return false; //限定左子树的最大值是root.val //限定右子树的最小值是root.val return isValidBST(root.left, min, root) &amp;&amp; isValidBST(root.right, root, max);} 插入一个数数据结构的操作无非遍历+访问，遍历就是找，访问就是改。 BST涉及到改，函数就要返回TreeNode类型，并且对递归调用的返回值进行接收。 123456789101112TreeNode insertIntoBST(TreeNode root, int val){ //找到空位置插入 if(root == null) return new TreeNode(val); //if(root.val == val) // BST 一般不会插入已经存在元素 if(root.val &lt; val) root.right = insertIntoBST(root.right, val); if(root.val &gt; val) root.left = insertIntoBST(root.left, val); return root;} 删除一个数先搭框架 12345678910TreeNode deleteNode(TreeNode root, int key){ if(root.val == key){ //找到 进行删除 }else if(root.val &gt; key){ root.left = deleteNode(root.left, key); }else if(root.val &lt; key){ root.right = deleteNode(root.right, key); } return root;} 关于删除方法： 如果为左右孩子都是空，直接删除 如果只有一个非空子节点，让该孩子继位 如果有2个非空子节点，让左子树最大或右子树最小继位 12345678910111213141516171819202122TreeNode deleteNode(TreeNode root, int key){ if(root == null) return null; if(root.val == key){ //先把1 2 处理 if(root.left == null) return root.right; if(root.right == null) return root.left; //处理3 //右子树最小 TreeNode minnode = getMin(root.right); //删除右子树最小的节点 root.right = deleteNode(root.right, minnode.val); //用最小节点替换root minnode.left = root.left; minnode.right = root.right; root = minnode; }else if(root.val &gt; key){ root.left = deleteNode(root.left, key); }else if(root.val &lt; key){ root.right = deleteNode(root.right, key); } return root;} 123456TreeNode getMin(TreeNode node){ //BST 最左边的就是最小的 while(node.left != null) node = node.left; return node;} 思考：为什么要替换root，直接改val不行吗，就像下面一样 123TreeNode minnode = getMin(root.right);root.right = deleteNode(root.right, minnode.val);root.val = minnode.val; Answer：一般来说，我们不会通过修改节点内部的值来交换结点。在实际应用中，BST结点内部的数据域是用户自定义的，可以非常复杂。而BST作为数据结构（一个工具人），其操作应该和内部存储的数据域解耦，所以更倾向使用指针操作来交换结点，没必要关心内部数据。 构造二叉搜索树题目96 Unique Binary Search Trees medium 95 Unique Binary Search Trees II medium 二叉搜索树之后序题目1373 Maximum Sum BST in Binary Tree hard 应用很多时候后序遍历用的好，可以大幅提升算法效率 快速排序题目912 Sort an Array medium 215 Kth Largest Element in an Array medium Reference微信推文讲解快速排序 B站视频讲解 思路 选定pivot中心轴 大于pivot的数字放在pivot右边 小于pivot的数字放在pivot的左边 分别对左右子序列重复前面3步操作 框架简约版代码1234567891011void sort(int[] nums, int lo, int hi){ if(lo &gt;= hi){ return; } //对nums[lo..hi]进行切分 //使得nums[lo..p-1] &lt;= nums[p] &lt; nums[p+1..hi] int p = partition(nums,lo,hi); //去左右子数组进行切分 sort(nums, lo, p-1); sort(nums, p+1, hi);} 你甚至可以这样理解：快速排序的过程是一个构造二叉搜索树的过程。 但谈到二叉搜索树的构造，那就不得不说二叉搜索树不平衡的极端情况，极端情况下二叉搜索树会退化成一个链表，导致操作效率大幅降低。 快速排序的过程中也有类似的情况，比如我画的图中每次 partition 函数选出的分界点都能把 nums[lo..hi] 平分成两半，但现实中你不见得运气这么好。 我们为了避免出现这种极端情况，需要引入随机性。 常见的方式是在进行排序之前对整个数组执行 洗牌算法 进行打乱，或者在 partition函数中随机选择数组元素作为分界点，本文会使用前者。 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Quick{ public static void sort(int[] nums){ //为了避免出现耗时的极端情况，先随机打乱 shuffle(nums); //排序整个数组 原地修改 sort(nums, 0, nums.length - 1); } private static void sort(int[] nums, int lo, int hi){ if(lo &gt;= hi) return; //对nums[lo..hi]进行切分 //使得nums[lo..p-1] &lt;= nums[p] &lt; nums[p+1..hi] int p = partition(nums, lo, hi); sort(nums, lo, p-1); sort(nums, p+1, hi); } //对nums[lo..hi]进行切分 private static int partition(int[] nums, int lo, int hi){ int pivot = nums[lo]; // 关于区间的边界控制需格外小心，稍有不慎就会出错 // 我这里把 i, j 定义为开区间，同时定义： // [lo, i) &lt;= pivot；(j, hi] &gt; pivot // 之后都要正确维护这个边界区间的定义 int i = lo + 1, j = hi; // 当 i &gt; j 时结束循环，以保证区间 [lo, hi] 都被覆盖 while (i &lt;= j) { while (i &lt; hi &amp;&amp; nums[i] &lt;= pivot) { i++; // 此 while 结束时恰好 nums[i] &gt; pivot } while (j &gt; lo &amp;&amp; nums[j] &gt; pivot) { j--; // 此 while 结束时恰好 nums[j] &lt;= pivot } // 此时 [lo, i) &lt;= pivot &amp;&amp; (j, hi] &gt; pivot if (i &gt;= j) { break; } swap(nums, i, j); } // 将 pivot 放到合适的位置，即 pivot 左边元素较小，右边元素较大 swap(nums, lo, j); return j; } // 洗牌算法，将输入的数组随机打乱 private static void shuffle(int[] nums) { Random rand = new Random(); int n = nums.length; for (int i = 0 ; i &lt; n; i++) { // 生成 [i, n - 1] 的随机数 int r = i + rand.nextInt(n - i); swap(nums, i, r); } } // 原地交换数组中的两个元素 private static void swap(int[] nums, int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; }} 稳定性分析还有一点需要注意的是，快速排序是「不稳定排序」，与之相对的，前文讲的 归并排序 是「稳定排序」。 对于序列中的相同元素，如果排序之后它们的相对位置没有发生改变，则称该排序算法为「稳定排序」，反之则为「不稳定排序」。 复杂度分析显然，快速排序的时间复杂度主要消耗在 partition 函数上，因为这个函数中存在循环。 所以 partition 函数到底执行了多少次？每次执行的时间复杂度是多少？总的时间复杂度是多少？ partition 执行的次数是二叉树节点的个数，每次执行的复杂度就是每个节点代表的子数组 nums[lo..hi] 的长度，所以总的时间复杂度就是整棵树中「数组元素」的个数。 假设数组元素个数为 N，那么二叉树每一层的元素个数之和就是 O(N)；分界点分布均匀的理想情况下，树的层数为 O(logN)，所以理想的总时间复杂度为 O(NlogN)。 由于快速排序没有使用任何辅助数组，所以空间复杂度就是递归堆栈的深度，也就是树高 O(logN)。 当然，我们之前说过快速排序的效率存在一定随机性，如果每次 partition 切分的结果都极不均匀：快速排序就退化成选择排序了，树高为 O(N)，每层节点的元素个数从 N 开始递减，总的时间复杂度为： N + (N - 1) + (N - 2) + ... + 1 = O(N^2) 所以我们说，快速排序理想情况的时间复杂度是 O(NlogN)，空间复杂度 O(logN)，极端情况下的最坏时间复杂度是 O(N^2)，空间复杂度是 O(N)。 215 用快排解决我自己写的哦~ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution { int res; public int findKthLargest(int[] nums, int k) { res = nums[0]; int tar = nums.length - k; sort(nums, 0, nums.length-1, tar); return res; } void sort(int[] nums, int lo, int hi, int tar){ if(lo &gt; hi) //这里从lo &gt;= hi 改成 lo &gt; hi eg:[2, 1] 2 --&gt; 1 return; int p = partition(nums, lo, hi, tar); if(p == tar){ res = nums[p]; return; } sort(nums, lo, p-1, tar); sort(nums, p+1, hi, tar); } int partition(int[] nums, int lo, int hi, int tar){ int p = nums[lo]; int i = lo + 1, j = hi; while(i &lt;= j){ while(i &lt; hi &amp;&amp; nums[i] &lt;= p){ i++; } while(j &gt; lo &amp;&amp; nums[j] &gt; p){ j--; } if(i &gt;= j) break; swap(nums, i, j); } swap(nums, lo, j); if(j == tar){ res = nums[j]; } return j; } void swap(int[] nums, int i, int j){ int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; }}","link":"/2022/04/24/2.2%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"title":"Create My Website","text":"My Blog URL部署链接：https://happyhappychan.github.io/ 本地测试链接：http://localhost:4000/ Blog Framework使用的是知乎上推荐很多的Blog Framework——Hexo Preparation在使用Hexo之前，需要安装好Node.js和npm Node.js 简单的说 Node.js 就是运行在服务端的 JavaScript。 Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。 由于Node.js平台是在后端运行JavaScript代码，所以，必须首先在本机安装Node环境。 Node.js 是能够在服务器端运行 JavaScript 的开放源代码、跨平台执行环境.from wiki npm npm其实是Node.js的包管理工具（package manager） 为啥我们需要一个包管理工具呢？因为我们在Node.js上开发时，会用到很多别人写的JavaScript代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生：大家都把自己开发的模块打包后放到npm官网上，如果要使用，直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。 更重要的是，如果我们要使用模块A，而模块A又依赖于模块B，模块B又依赖于模块X和模块Y，npm可以根据依赖关系，把所有依赖的包都下载下来并管理起来。否则，靠我们自己手动管理，肯定既麻烦又容易出错。 Test npm 12C:\\Users\\MagicKD&gt;npm -v8.5.0 Test Node.js 12C:\\Users\\MagicKD&gt;node -vv16.14.2 Tutorial具体使用 Hexo和GitHub搭建的网页参考了知乎分享的教程GitHub+Hexo 搭建个人网站详细教程 值得注意的是，这篇教程有点历史了，所以有些操作描述不太正确，记得看评论区！ 1 Install HexoHexo官网说的是 1$ npm install -g hexo-cli 但是，用上面那种方法，根本下载不下来，因此要修改镜像。修改方法如下： 这里是通过命令行临时指定镜像的方式 1npm install -g hexo-cli --registry=https://registry.npm.taobao.org 参考链接：修改npm镜像 2 Init Blog 第一步，先找个地方创建存放blog的文件夹 1F:\\github_data\\Github_Blogs 第二步，找到代理端口7890 我是从clash for windows 上查看的 第三步，设置代理 在git bash或者cmd控制台输入git config –global http.proxy localhost:7890上面xxxx输入自己代理端口号，四位数，输入在执行hexo init 命令就好了，下面图片是我看到·的解决办法，极大的帮助了我 取消全局代理的命令：git config –global –unset http.proxy 别人说这个方法不行，一开始设置了代理，现在要取消全局代理，然后就按照上面的命令取消了全局代理。 第四步，直接hexo init 上面的2 3 都失败后【已经根据命令取消全局代理了】，就打算开着clash for windows 和 paofucloud，在下面这个状态下直接 hexo init，挂一个晚上。 结果，上个厕所回来打算睡觉的时候，发现成功了！ 第五步，测试环境 12345MagicKD@LAPTOP-M9O0BF78 MINGW64 /f/github_data/Github_Blogs$ hexo sINFO Validating configINFO Start processingINFO Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop. 第六步，下载喜欢的模板 1234567MagicKD@LAPTOP-M9O0BF78 MINGW64 /f/github_data/Github_Blogs$ cnpm install√ Installed 10 packages√ Linked 0 latest versions√ Run 0 scripts√ All packages installed (used 42ms(network 39ms), speed 0B/s, json 0(0B), tarball 0B, manifests cache hit 0, etag hit 0 / miss 0) 12MagicKD@LAPTOP-M9O0BF78 MINGW64 /f/github_data/Github_Blogs$ git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus --depth 1 第七步，配置环境 123MagicKD@LAPTOP-M9O0BF78 MINGW64 /f/github_data/Github_Blogs$ hexo config theme icarusINFO Validating config 第八步，测试模板 1234567891011121314151617MagicKD@LAPTOP-M9O0BF78 MINGW64 /f/github_data/Github_Blogs$ hexo serverINFO Validating configInferno is in development mode.INFO ======================================= ██╗ ██████╗ █████╗ ██████╗ ██╗ ██╗███████╗ ██║██╔════╝██╔══██╗██╔══██╗██║ ██║██╔════╝ ██║██║ ███████║██████╔╝██║ ██║███████╗ ██║██║ ██╔══██║██╔══██╗██║ ██║╚════██║ ██║╚██████╗██║ ██║██║ ██║╚██████╔╝███████║ ╚═╝ ╚═════╝╚═╝ ╚═╝╚═╝ ╚═╝ ╚═════╝ ╚══════╝=============================================INFO === Checking package dependencies ===INFO === Checking theme configurations ===INFO === Registering Hexo extensions ===INFO Start processingINFO Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop. 3 Publish 1 配置站点文件 在blog根目录里的_config.yml文件称为站点配置 进入根目录里的themes文件夹，里面也有个_config.yml文件，这个称为主题配置文件 下一步将我们的Hexo与GitHub关联起来，打开站点的配置文件_config.yml，翻到最后修改为： deploy:type: gitrepo: 这里填入你之前在GitHub上创建仓库的完整路径，记得加上 .gitbranch: master参考如下： 1234deploy: type: git repo: https://github.com/HappyhappyChan/HappyhappyChan.github.io.git branch: master 2 安装Git部署插件 最后安装Git部署插件, 123456789MagicKD@LAPTOP-M9O0BF78 MINGW64 /f/github_data/Github_Blogs$ npm install hexo-deployer-git --saveadded 1 package, and audited 447 packages in 4s28 packages are looking for funding run `npm fund` for detailsfound 0 vulnerabilities 发现直接上面完成直接进入第三步会失败，于是用cnpm再安装一次 1cnpm install hexo-deployer-git --save 3 Hexo 实现部署 1234hexo cleanhexo generatehexo deploy# 以上3条命令依次执行 ==尝试1==失败 在部署的时候一直显示login fail, 怀疑是验证失败，然后根据这个链接生成一个personal token ghp_xyA4B6xWI……【2022-04-12 有效期30天，看github_data/git.txt】 ==尝试2==成功deploy 参考hexo-d失败的解决方法 123456789101112131415161718192021C:\\Users\\MagicKD&gt;ssh-keygen -t rsa -C &quot;1214999431@qq.com&quot;Generating public/private rsa key pair.Enter file in which to save the key (C:\\Users\\MagicKD/.ssh/id_rsa):Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in C:\\Users\\MagicKD/.ssh/id_rsa.Your public key has been saved in C:\\Users\\MagicKD/.ssh/id_rsa.pub.The key fingerprint is:The key's randomart image is:+---[RSA 2048]----+| BO%o. || ooOoB o || oo+.o = o || .o+ . o o.. || o...S ...o .o|| ...o .+.. o oo|| o oo . ..|| ..o .|| ..o .E|+----[SHA256]-----+ 配置站点文件 12345deploy: type: git #repo: https://github.com/HappyhappyChan/HappyhappyChan.github.io.git repo: git@github.com:HappyhappyChan/HappyhappyChan.github.io.git branch: master 1234deploy: type: git repo: git@github.com:HappyhappyChan/HappyhappyChan.github.io.git branch: main Github Page 404如果前面都运行正常，结果还是pages 404。 这应该是浏览器缓存的问题，我用的是360浏览器，点击右上角工具，然后点击清除上网痕迹，即可解决。 另一个办法是换一个浏览器访问。 我的解决方法：一开始一直用Chrome， 然后换了搜狗浏览器，就可以正常打开了。 Hexo Command123456789101112131415npm install hexo -g #安装Hexonpm update hexo -g #升级hexo init #初始化博客命令简写hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令 Debug然后打开cmd，采用管理员方式，进入 Github_Blogs，在命令行输入 1hexo init 发现npm还是太慢了，于是下载cnpm 1npm install -g cnpm --registry=https://registry.npm.taobao.org 测试cnpm是否安装成功 123456789cnpm -vC:\\Users\\MagicKD&gt;cnpm -vcnpm@7.1.1 (C:\\Users\\MagicKD\\AppData\\Roaming\\npm\\node_modules\\cnpm\\lib\\parse_argv.js)npm@6.14.16 (C:\\Users\\MagicKD\\AppData\\Roaming\\npm\\node_modules\\cnpm\\node_modules\\npm\\lib\\npm.js)node@16.14.2 (F:\\Node-js-16.14.2x64\\node.exe)npminstall@5.8.0 (C:\\Users\\MagicKD\\AppData\\Roaming\\npm\\node_modules\\cnpm\\node_modules\\npminstall\\lib\\index.js)prefix=C:\\Users\\MagicKD\\AppData\\Roaming\\npmwin32 x64 10.0.18362registry=https://registry.npmmirror.com 使用cnpm 1cnpm info underscore hexo init 要在管理员身份下进行？ 1hexo init blog 12hexo init blog --registry=https://registry.npm.taobao.org# 这个试过也不行…… ReferenceHexo部署 Hexo+Github: 个人博客网站搭建完全教程 搭建个人博客网站教程","link":"/2022/04/12/Create-My-Website/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/04/12/hello-world/"},{"title":"Hexo Theme Modification: Icarus","text":"Preface花了不少功夫配置网站，到今天终于搞的差不多啦，就拿这一篇大致记录一下如何配置 Hexo Theme 中的 Icarus 5.0.0 version~ 参考了Reference里面的许多代码，但是个别代码有问题，所以不能单纯的ctrl+v/c，遇到问题根据vscode报错好好debug。Icarus不同版本代码有挺大差别的，Icon的选取也要注意是不是pro / free。 个性化配置logo_config.icarus.yml 12345logo: /img/crayon-shinchan-logo.svg # text: HappyhappyChan's Bloghead: favicon: /img/crayon-shinchan-logo.svg Avatar_config.icarus.yml 123avatar: /img/Himawali.png avatar_rounded: True #false gravatar: #chenlh65@mail2.sysu.edu.cn gravatar如果不为空，会优先指向这个对应的链接。如果为空，就取avatar里面的地址 导航栏_config.icarus.yml 1234567891011121314151617181920212223navbar: menu: Home: / Archives: /archives Categories: /categories Tags: /tags About: /about links: Fork me on GitHub: icon: fab fa-github url: https://github.com/HappyhappyChanarticle: highlight: # 代码高亮主题 # https://github.com/highlightjs/highlight.js/tree/master/src/styles theme: atom-one-light # 显示复制代码按钮 clipboard: true # 代码块的默认折叠状态。可以是&quot;&quot;, &quot;folded&quot;, &quot;unfolded&quot; fold: unfolded readtime: true update_time: auto #设置为false来隐藏所有文章的更新时间，或设置为auto而在文章的更新时间 与发布时间相同时隐藏更新时间 licenses: Footer_config.icarus.yml 1234567891011footer: links: Creative Commons: icon: fab fa-creative-commons url: https://creativecommons.org/ Attribution 4.0 International: icon: fab fa-creative-commons-by url: https://creativecommons.org/licenses/by/4.0/ Fork Me on GitHub: icon: fab fa-github url: https://github.com/HappyhappyChan 代码高亮_config.icarus.yml 如果你已在Hexo中启用了代码高亮功能，你可以通过article中的highlight设置来自定义代码块。 请从highlight.js/src/styles下列出的所有主题中 选择一个主题。 然后，复制文件名(不带.css后缀)到theme设置项中。 如要隐藏复制代码按钮，将clipboard设置为false。 如果你希望折叠或展开所有代码块，将fold设置为&quot;folded&quot;或&quot;unfolded&quot;。 你也可以将fold设置为空来禁止代码块折叠。 123456789article: highlight: # 代码高亮主题 # https://github.com/highlightjs/highlight.js/tree/master/src/styles theme: atom-one-light # 显示复制代码按钮 clipboard: true # 代码块的默认折叠状态。可以是&quot;&quot;, &quot;folded&quot;, &quot;unfolded&quot; fold: unfolded Coverxx.md 12345678910title: 'Hexo Theme Modification: Icarus'date: 2022-04-13 10:31:14tags:- Hexo- Websitecategories: - Coding- Webcover: /img/covers/Hexo-Theme-Modification-Icarus.pngthumbnail: /img/covers/Hexo-Theme-Modification-Icarus.png Reading Time12article: readtime: true Updated Time_config.icarus.yml 1234title: Icarus快速上手updated: 2020-04-01 00:00:00---Post content... 然后，将主题配置文件的article部分的update_time设置为true： 12article: update_time: true 你也可以将update_time设置为false来隐藏所有文章的更新时间，或设置为auto而在文章的更新时间 与发布时间相同时隐藏更新时间。 License_config.icarus.yml 1234567article: # 文章许可协议 licenses: Creative Commons: icon: fab fa-creative-commons url: 'https://creativecommons.org/' 'CC BY-NC-SA 4.0': 'https://creativecommons.org/licenses/by-nc-sa/4.0/' _config.yml 123456789title: HappyhappyChan's-Blogsubtitle: ''description: ''keywords: nullauthor: Happyhappy Chanlanguage: entimezone: ''url: https://happyhappychan.github.io/permalink: ':year/:month/:day/:title/' Sidebar_config.icarus.yml 12345sidebar: left: sticky: false right: sticky: true Priority除了在_config.icarus.yml的默认主题配置文件外，Icarus也会从如下位置获取替代配置： 位于_config.yml的站点配置文件 位于_config.post.yml和_config.page.yml的布局配置文件 文章/页面的front-matter (已弃用) 位于themes/icarus/_config.yml的旧主题配置文件 (已弃用) 位于themes/icarus/_config.post.yml和themes/icarus/_config.page.yml的旧布局配置文件 总而言之，配置源的作用范围和优先级如下： 对于某个文章或页面 文章/页面的front-matter覆盖所有下面的配置源。 布局配置文件覆盖所有下面的配置源。 站点配置文件中的theme_config选项覆盖所有下面的配置源。 主题配置文件覆盖所有下面的配置源。 站点配置文件。 对于所有的文章或页面 布局配置文件覆盖所有下面的配置源。 站点配置文件中的theme_config选项覆盖所有下面的配置源。 主题配置文件覆盖所有下面的配置源。 站点配置文件。 对于所有的文章，页面，和索引页 站点配置文件中的theme_config选项覆盖所有下面的配置源。 主题配置文件覆盖所有下面的配置源。 站点配置文件。 Category123categories: - Coding- Web 显示为： Coding Web Icon使用的是fontawesome 5.15版本的图标，如果页面不能正常显示图标，思考 图标版本 图标是否免费 查看图片是否付费 _config.icarus.yml 123456Github: icon: fab fa-github url: https://github.com/HappyhappyChan Email: icon: fas fa-envelope url: mailto:chenlh65@mail2.sysu.edu.cn Mailto邮件点击发送的功能 _config.icarus.yml 123Email: icon: fas fa-envelope url: mailto:chenlh65@mail2.sysu.edu.cn 布局文章页面设为两栏布局在_config.icarus.yml目录下，创建_config.post.yml文件，该文件内容与_config.icarus.yml文件一样，用于单独加载post界面布局。注意，双栏需要将widgets内容的position都设置为同一边。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354widgets: - position: left type: profile author: HappyhappyChan author_title: Keep investigating location: China Mainland avatar: /img/Himawali.png avatar_rounded: True #false gravatar: #chenlh65@mail2.sysu.edu.cn follow_link: https://github.com/HappyhappyChan social_links: Github: icon: fab fa-github url: https://github.com/HappyhappyChan Email: icon: fas fa-envelope # url: https://facebook.com url: mailto:chenlh65@mail2.sysu.edu.cn Twitter: icon: fab fa-twitter # url: https://twitter.com url: / Dribbble: icon: fab fa-dribbble # url: https://dribbble.com url: / RSS: icon: fas fa-rss url: / - position: left type: toc index: true collapsed: true depth: 3 # - # position: left # type: links # links: # Hexo: https://hexo.io # Bulma: https://bulma.io - position: left type: categories - position: left #left type: recent_posts - position: left #left type: archives - position: left #left type: tags 增加两栏布局下文章的宽度12345// layout/layout.jsx &lt;Head site={site} config={config} helper={helper} page={page} /&gt;- &lt;body class={`is-${columnCount}-column`}&gt;+ &lt;body class={`is-3-column`}&gt; &lt;Navbar config={config} helper={helper} page={page} /&gt; 12345//layout/layout.jsx 'is-12': columnCount === 1,- 'is-8-tablet is-8-desktop is-8-widescreen': columnCount === 2,+ 'is-8-tablet is-8-desktop is-9-widescreen': columnCount === 2, 'is-8-tablet is-8-desktop is-6-widescreen': columnCount === 3 123456789// layout/common/widgets.jsxfunction getColumnSizeClass(columnCount) { switch (columnCount) { case 2:- return 'is-4-tablet is-4-desktop is-4-widescreen';+ return 'is-4-tablet is-4-desktop is-3-widescreen'; case 3: return 'is-4-tablet is-4-desktop is-3-widescreen'; } 优化不同屏幕大小下的宽度123456789101112131415161718# include/style/responsive.styl +widescreen()+ .is-3-column .container+ max-width: $widescreen - $gap+ width: $widescreen - $gap+ .is-1-column .container, .is-2-column .container max-width: $desktop - 2 * $gap width: $desktop - 2 * $gap +fullhd()+ .is-3-column .container+ max-width: $fullhd - 2 * $gap+ width: $fullhd - 2 * $gap+ .is-2-column .container max-width: $widescreen - 2 * $gap width: $widescreen - 2 * $gap 优化标题布局这里将标题移动到正文上方，增加了更新时间，以及相对应的图标。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//layout/common/article.jsx&lt;div class=&quot;card&quot;&gt; {/* Thumbnail */} {cover ? &lt;div class=&quot;card-image&quot;&gt; {index ? &lt;a href={url_for(page.link || page.path)} class=&quot;image is-7by3&quot;&gt; &lt;img class=&quot;fill&quot; src={cover} alt={page.title || cover} /&gt; &lt;/a&gt; : &lt;span class=&quot;image is-7by3&quot;&gt; &lt;img class=&quot;fill&quot; src={cover} alt={page.title || cover} /&gt; &lt;/span&gt;} &lt;/div&gt; : null} &lt;article class={`card-content article${'direction' in page ? ' ' + page.direction : ''}`} role=&quot;article&quot;&gt; {/* Metadata */} {/* Title */} &lt;h1 className=&quot;title is-size-3 is-size-4-mobile has-text-weight-normal&quot;&gt; {index ? &lt;a class=&quot;link-muted&quot; href={url_for(page.link || page.path)}&gt;{page.title}&lt;/a&gt; : page.title} &lt;/h1&gt; {page.layout !== 'page' ? &lt;div class=&quot;article-meta is-size-7 is-uppercase level is-mobile&quot;&gt; &lt;div class=&quot;level-left&quot;&gt; {/* Creation Date */} {/* {page.date &amp;&amp; &lt;span class=&quot;level-item&quot; dangerouslySetInnerHTML={{ __html: _p('article.created_at', `&lt;time dateTime=&quot;${date_xml(page.date)}&quot; title=&quot;${new Date(page.date).toLocaleString()}&quot;&gt;${date(page.date)}&lt;/time&gt;`) }}&gt;&lt;/span&gt;} */} {page.date &amp;&amp; &lt;span class=&quot;level-item&quot;&gt; &lt;i className=&quot;far fa-calendar-alt&quot;&gt;&amp;nbsp;&lt;/i&gt; &lt;time dateTime={date_xml(page.date)} title={date_xml(page.date)}&gt;{date(page.date)}&lt;/time&gt; &lt;/span&gt;} {/* Last Update Date */} {/* {shouldShowUpdated &amp;&amp; &lt;span class=&quot;level-item&quot; dangerouslySetInnerHTML={{ __html: _p('article.updated_at', `&lt;time dateTime=&quot;${date_xml(page.updated)}&quot; title=&quot;${new Date(page.updated).toLocaleString()}&quot;&gt;${date(page.updated)}&lt;/time&gt;`) }}&gt;&lt;/span&gt;} */} {shouldShowUpdated &amp;&amp; &lt;span class=&quot;level-item is-hidden-mobile&quot;&gt; {/* &lt;i class=&quot;far fa-calendar-edit&quot;&gt;&lt;/i&gt; 因为是专业版 所以不能免费用……*/ } &lt;i class=&quot;far fa-calendar-check&quot;&gt;&amp;nbsp;&lt;/i&gt; &lt;time dateTime={date_xml(page.updated)} title={date_xml(page.updated)}&gt;{date(page.updated)}&lt;/time&gt; &lt;/span&gt;} {/* author */} {page.author ? &lt;span class=&quot;level-item&quot;&gt; {page.author} &lt;/span&gt; : null} {/* Categories */} {page.categories &amp;&amp; page.categories.length ? &lt;span class=&quot;level-item&quot;&gt; &lt;i className=&quot;far fa-folder-open&quot;&gt;&amp;nbsp;&lt;/i&gt; {(() =&gt; { const categories = []; page.categories.forEach((category, i) =&gt; { categories.push(&lt;a class=&quot;link-muted&quot; href={url_for(category.path)}&gt;{category.name}&lt;/a&gt;); if (i &lt; page.categories.length - 1) { categories.push(&lt;span&gt;&amp;nbsp;/&amp;nbsp;&lt;/span&gt;); } }); return categories; })()} &lt;/span&gt; : null} {/* Read time */} {article &amp;&amp; article.readtime &amp;&amp; article.readtime === true ? &lt;span class=&quot;level-item&quot;&gt; &lt;i class=&quot;far fa-clock&quot;&gt;&amp;nbsp;&lt;/i&gt; {(() =&gt; { const words = getWordCount(page._content); const time = moment.duration((words / 150.0) * 60, 'seconds'); return `${_p('article.read_time', time.locale(index ? indexLaunguage : language).humanize())} (${_p('article.word_count', words)})`; })()} &lt;/span&gt; : null} {/* Visitor counter */} {!index &amp;&amp; plugins &amp;&amp; plugins.busuanzi === true ? &lt;span class=&quot;level-item&quot; id=&quot;busuanzi_container_page_pv&quot; dangerouslySetInnerHTML={{ __html: _p('plugin.visit_count', '&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;0&lt;/span&gt;') }}&gt;&lt;/span&gt; : null} &lt;/div&gt; &lt;/div&gt; : null} {/* Title */} {/* {page.title !== '' ? &lt;h1 class=&quot;title is-3 is-size-4-mobile&quot;&gt; {index ? &lt;a class=&quot;link-muted&quot; href={url_for(page.link || page.path)}&gt;{page.title}&lt;/a&gt; : page.title} &lt;/h1&gt; : null} */} {/* Content/Excerpt */} &lt;div class=&quot;content&quot; dangerouslySetInnerHTML={{ __html: index &amp;&amp; page.excerpt ? page.excerpt : page.content }}&gt;&lt;/div&gt; {/* Licensing block */} 标题下方的发布时间与更新时间均改为直接使用日期。 123456//source/js/main.js- if (typeof moment === 'function') {- $('.article-meta time').each(function() {- $(this).text(moment($(this).attr('datetime')).fromNow());- });- } 优化文章结尾布局在文章结尾增加一个hr以调整间距。另外设置在预览时也显示标签（tags），并将Read More按钮置于右侧且添加图标 1234567891011121314151617181920212223//layout/common/article.jsx{/* Licensing block */} {!index &amp;&amp; article &amp;&amp; article.licenses &amp;&amp; Object.keys(article.licenses) ? &lt;ArticleLicensing.Cacheable page={page} config={config} helper={helper} /&gt; : null} &lt;hr style=&quot;height:1px;margin:1rem 0&quot;/&gt; &lt;div className=&quot;level is-mobile is-flex&quot;&gt; {/* Tags */} {/* {!index &amp;&amp; page.tags &amp;&amp; page.tags.length ? &lt;div class=&quot;article-tags is-size-7 mb-4&quot;&gt; &lt;span class=&quot;mr-2&quot;&gt;#&lt;/span&gt; {page.tags.map(tag =&gt; { return &lt;a class=&quot;link-muted mr-2&quot; rel=&quot;tag&quot; href={url_for(tag.path)}&gt;{tag.name}&lt;/a&gt;; */} {page.tags &amp;&amp; page.tags.length ? &lt;div class=&quot;article-tags is-size-7 is-uppercase&quot;&gt; &lt;i class=&quot;fas fa-tags has-text-grey&quot;&gt;&lt;/i&gt;&amp;nbsp; {page.tags.map((tag, index) =&gt; { return &lt;a class=&quot;link-muted&quot; rel=&quot;tag&quot; href={url_for(tag.path)}&gt;{tag.name}{index !== page.tags.length-1? ', ':''}&lt;/a&gt;; })} &lt;/div&gt; : null} {/* &quot;Read more&quot; button */} {/* {index &amp;&amp; page.excerpt ? &lt;a class=&quot;article-more button is-small is-size-7&quot; href={`${url_for(page.link || page.path)}#more`}&gt;{__('article.more')}&lt;/a&gt; : null} */} {index &amp;&amp; page.excerpt ? &lt;a class=&quot;article-more button is-small is-size-7&quot; href={`${url_for(page.link || page.path)}#more`}&gt;&lt;i class=&quot;fas fa-book-reader has-text-grey&quot;&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;{__('article.more')}&lt;/a&gt; : null} &lt;/div&gt; {/* Share button */} 目录粘性定位12# _config.ymltoc: true #为了增加目录 1234//source/js/main.jsif ($toc.length &gt; 0) {+ $toc.addClass('column-left is-sticky'); const $mask = $('&lt;div&gt;'); 1234//include/style/widget.styl+#toc+ max-height: calc(100vh - 22px)+ overflow-y: scroll 功能夜间模式复制下面的代码，然后在./themes/icarus/source/css/目录下创建night.styl文件并粘贴 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378dark-primary-color = rgb(55, 61, 72)dark-primary-color-hover = rgb(67, 74, 86)dark-primary-color-active = rgb(44, 49, 58)dark-font-color = #c0c0c0#universe display: none.navbar-logo,.footer-logo .logo-img-dark display: nonebody.night background: #0e1225.night // code highlight (https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css) // navigation bar, cards .content code color: rgb(203,186,125) // night icon changed to fas fa-sun #night-nav #night-icon:before content: '\\f185' .navbar-menu background-color: inherit .navbar-main .navbar-menu .navbar-item &amp;:hover, &amp;:focus color: #ffffff background-color: dark-primary-color .navbar, .card background-color: rgba(40, 44, 52, 0.5) backdrop-filter: none -webkit-backdrop-filter: none .card &amp;:hover background-color: rgba(40, 44, 52, 0.8) .footer background-color: rgba(40, 44, 52, 0.5) backdrop-filter: none -webkit-backdrop-filter: none &amp;:before background-color: rgba(40, 44, 52, 0.5) // input .input, .textarea background-color: dark-primary-color-hover border-color: dark-primary-color // message .message.message-immersive background-color: #c2c2c2 .message-body color: #222222 .message.message-immersive.is-info background-color: #bdc3c8 .message-body color: #004779 .message.message-immersive.is-warning background-color: #cbc8ba .message-body color: #5b4b00 .message.message-immersive.is-danger background-color: #c6babe .message-body color: #79000f .message.message-immersive.is-success background-color: #bfc7c0 .message-body color: #1e4d1c .message.message-immersive.is-primary background-color: #bdc0c9 .message-body color: #003790 // button .button.is-primary, .button.is-light, .button.is-small background-color: dark-primary-color color: dark-font-color &amp;:hover, &amp;.is-hovered color: #ffffff background-color: dark-primary-color-hover &amp;:active, &amp;.is-active color: #ffffff background-color: dark-primary-color-active .button.is-white, .button.is-transparent background-color: transparent &amp;:hover background-color: dark-primary-color !important .pagination .pagination-next, .pagination .pagination-previous .pagination-link:not(.is-current) color: dark-font-color // button .button.is-primary, .button.is-light, .button.is-small background-color: dark-primary-color color: dark-font-color &amp;:hover, &amp;.is-hovered color: #ffffff background-color: dark-primary-color-hover &amp;:active, &amp;.is-active color: #ffffff background-color: dark-primary-color-active .button.is-white, .button.is-transparent background-color: transparent &amp;:hover background-color: dark-primary-color !important .pagination .pagination-next, .pagination .pagination-previous .pagination-link:not(.is-current) color: dark-font-color background-color: dark-primary-color a color: dark-font-color .pagination-link.is-current background-color: dark-primary-color-hover border-color: dark-primary-color-hover // comment .v .vwrap, .v .vwrap .vheader .vinput border-color: dark-primary-color .v .vwrap .vheader .vinput:focus border-color: dark-primary-color-hover .v .vbtn color: dark-font-color background-color: dark-primary-color border-color: dark-primary-color &amp;:hover background-color: dark-primary-color-hover &amp;:active background-color: dark-primary-color-active .v .vlist .vcard .vhead .vsys background-color: dark-primary-color .v a:hover, .v .vlist .vcard .vh .vmeta .vat color: #ffffff .v .vlist .vcard .vcontent.expand:before background: -webkit-gradient(linear, left top, left bottom, from(rgba(37, 41, 54, 0)), to(rgba(37, 41, 54, 1))) background: linear-gradient(180deg, rgba(37, 41, 54, 0), rgba(37, 41, 54, 1)) .v .vlist .vcard .vcontent.expand:after background: rgba(37, 41, 54, 1) .v .vlist .vcard .vh, .v .vlist .vcard .vquote border-color: dark-primary-color-hover // font color body, strong, time, .title, .footer, .card, .content h1, .content h2, .content h3, .content h4, .content h5, .content h6, .navbar-item, .navbar-item.is-active, .navbar-link, .menu-list a, .menu-label, .level-item, .input, .textarea, .button.is-white, .button.is-transparent, .article-licensing, .v * color: dark-font-color .media-content, .has-text-grey, .link-muted color: dark-font-color !important a color: rgb(82, 153, 224) &amp;:hover color: #ffffff // quote .content blockquote, .article-licensing background-color: dark-primary-color border-color: dark-primary-color-hover .post-copyright background-color: dark-primary-color border-color: dark-primary-color-hover // table .content table thead td, .content table thead th color: dark-font-color .content table td, .content table th border-color: dark-primary-color-hover // break line hr background-color: dark-primary-color-hover // tags and menus article.article, article.media .title:hover a // override anotherr !important color: dark-font-color !important .tag:not(body) color: dark-font-color background-color: dark-primary-color .tag.is-grey background-color: dark-primary-color-hover .menu-list a:hover background-color: dark-primary-color .menu-list a.is-active background-color: dark-primary-color-hover .menu-list li ul border-color: dark-primary-color // time line .timeline .media:last-child:after background-color: rgb(37, 41, 54) .timeline border-color: dark-primary-color-hover .timeline .media:before background-color: dark-primary-color-hover // search box .searchbox .searchbox-container, .searchbox-header, .searchbox-header .searchbox-input, .searchbox-header .searchbox-close, .searchbox-body, .searchbox-result-section, .searchbox-result-item color: dark-font-color background-color: dark-primary-color border-color: dark-primary-color-hover .searchbox-container .searchbox-result-section .searchbox-result-item:hover, .searchbox-container .searchbox-result-section .searchbox-result-item.active, .searchbox-container .searchbox-header .searchbox-close:hover color: #ffffff background-color: dark-primary-color-hover // selection ::selection color: #ffffff background-color: rgba(52, 109, 167, 0.8) ::-moz-selection color: #ffffff background-color: rgba(52, 109, 167, 0.8) input:-webkit-autofill -webkit-text-fill-color: dark-font-color !important box-shadow: 0 0 0px 1000px dark-primary-color inset .hljs { display: block; overflow-x: auto; padding: 0.5em; color: #abb2bf; background: #282c34 } .hljs-comment, .hljs-quote { color: #5c6370; font-style: italic } .hljs-doctag, .hljs-keyword, .hljs-formula { color: #c678dd } .hljs-section, .hljs-name, .hljs-selector-tag, .hljs-deletion, .hljs-subst { color: #e06c75 } .hljs-literal { color: #56b6c2 } .hljs-string, .hljs-regexp, .hljs-addition, .hljs-attribute, .hljs-meta-string { color: #98c379 } .hljs-built_in, .hljs-class .hljs-title { color: #e6c07b } .hljs-attr, .hljs-variable, .hljs-template-variable, .hljs-type, .hljs-selector-class, .hljs-selector-attr, .hljs-selector-pseudo, .hljs-number { color: #d19a66 } .hljs-symbol, .hljs-bullet, .hljs-link, .hljs-meta, .hljs-selector-id, .hljs-title { color: #61aeee } .hljs-emphasis { font-style: italic } .hljs-strong { font-weight: bold } .hljs-link { text-decoration: underline } 接下来需要修改一下样式文件。 source/css/default.styl 12 @import 'style'+ @import 'night' 然后在./themes/icarus/source/js下创建night.js文件，其内容如下： 1234567891011121314151617181920212223242526272829303132333435363738(function () { /** * Icarus 夜间模式 by iMaeGoo * https://www.imaegoo.com/ */ var isNight = localStorage.getItem('night'); var nightNav; function applyNight(value) { if (value.toString() === 'true') { document.body.classList.remove('light'); document.body.classList.add('night'); } else { document.body.classList.remove('night'); document.body.classList.add('light'); } } function findNightNav() { nightNav = document.getElementById('night-nav'); if (!nightNav) { setTimeout(findNightNav, 100); } else { nightNav.addEventListener('click', switchNight); } } function switchNight() { isNight = isNight ? isNight.toString() !== 'true' : true; applyNight(isNight); localStorage.setItem('night', isNight); } findNightNav(); isNight &amp;&amp; applyNight(isNight);}()); 最后，还要修改一下下面两个文件。 layout/common/scripts.jsx 123 &lt;script src={url_for('/js/main.js')} defer&gt;&lt;/script&gt;+ &lt;script src={url_for('/js/night.js')} defer={true}&gt;&lt;/script&gt; &lt;/Fragment&gt;; layout/commom/navbar.jsx 12345 &lt;div class=&quot;navbar-end&quot;&gt;+ &lt;a class=&quot;navbar-item night&quot; id=&quot;night-nav&quot; title=&quot;Night Mode&quot; href=&quot;javascript:;&quot;&gt;+ &lt;i class=&quot;fas fa-moon&quot; id=&quot;night-icon&quot;&gt;&lt;/i&gt;+ &lt;/a&gt; {Object.keys(links).length ? &lt;Fragment&gt; Page View_config.icarus.yaml 12345678plugins: animejs: true back_to_top: true baidu_analytics: tracking_id: bing_webmaster: tracking_id: busuanzi: True #false 这个是用来计数的 layout/common/article.jsx 1234{/* Visitor counter */} {!index &amp;&amp; plugins &amp;&amp; plugins.busuanzi === true ? &lt;span class=&quot;level-item&quot; id=&quot;busuanzi_container_page_pv&quot; dangerouslySetInnerHTML={{ __html: _p('plugin.visit_count', '&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;0&lt;/span&gt;') }}&gt;&lt;/span&gt; : null} ReferenceIcarus用户指南 - 主题配置 Hexo自主文档 Icon-fontawesome FontAwesome 字体图标库 Icarus主题的一些常用配置 Hexo主题Icarus的自定义 icarus个性化配置 阿里矢量图 失踪人口回归系列之在VPS上搭建HEXO的GIT部署环境 在Hexo博客中发布文章 Epilogue耗时1.5天终于搞完啦，总之今后也要积极探索哟~ Going out into the world and investigating, turning the “unknown” into the “known”.","link":"/2022/04/13/Hexo-Theme-Modification-Icarus/"},{"title":"学习算法和刷题的框架思维","text":"Preface这个系列都是GitHub上fucking-algorithm这个项目的学习笔记。 数据结构的存储数据结构的存储方式只有2种：数组（顺序存储）和链表（链式存储）。 队列、栈这两种数据结构可以用链表也可以用数组实现： 用数组，要处理扩容、缩容 用链表，需要更多的内存空间存储节点 图 邻接表，链表 邻接矩阵，二维数组 判断连通性迅速 矩阵运算 散列表 通过散列函数把键映射到一个大数组里 解决散列冲突 拉链法：用到链表特性、操作简单、额外存储空间指针 线性探查法：数组特性、连续寻址、不需要指针存储 树 用数组实现就是堆 堆其实就是完全二叉树 用数组存储不需要指针结点 用链表实现 不一定是完全二叉树 常见链表树：二叉搜索树、AVL树、红黑树、区间树、B树 数组和链表的比较 数组 紧凑连续存储、随机访问、索引快、省空间 扩容麻烦，时间复杂度O(N) 删除插入麻烦，时间复杂度O(N) 链表 元素不连续，不存在扩容问题，O(1) 删除、插入时间复杂度O(1) 无法随机访问、消耗更多存储空间 数据结构的基本操作概况来说， 遍历+访问，具体地说，增删改查 实现形式2种：线性和非线性 线性：for / while 迭代 非线性：递归 数组遍历框架线性迭代结构 12345void traverse(int[] arr){ for(int i = 0; i &lt; arr.length; i++){ //迭代访问 arr[i] }} 链表遍历框架单链表基本的单链表结点 1234class ListNode{ int val; ListNode next;} 单链表迭代遍历 12345void traverse(ListNode head){ for(ListNode p = head; p != null; p = p.next){ //迭代访问 p.val }} 单链表递归遍历 1234void traverse(ListNOde head){ //递归访问 head.val traverse(head.next)} 二叉树基本的二叉树结点 1234class TreeNode{ int val; TreeNode left, right;} 二叉树遍历，典型的非线性递归遍历 1234void traverse(TreeNode root){ traverse(root.left); traverse(root.right);} N叉树基本的N叉树节点 1234class TreeNode{ int val; TreeNode[] children;} 遍历框架 12345void traverse(TreeNode root){ for(TreeNode: child: root.children){ traverse(child); }} N 叉树的遍历又可以扩展为图的遍历，因为图就是好几个N 叉棵树的结合体。你说图是可能出现环的？这个很 好办，用个布尔数组 visited 做标记就可了，这里就不写代码了 算法刷题指南刷题顺序 数组、链表基本数据结构基本算法，如单链表翻转、前缀、数组、二分搜索等 二叉树、二叉树、二叉树！！培养框架思维，本质上都是树的遍历问题 1234567void traverse(TreeNode root){ //前序位置 traverse(root.left); //中序位置 traverse(root.right); //后序位置} 算法本质本质是穷举，要求：无遗漏、无冗余。 如何穷举？ 如何聪明地穷举？ 常见的算法技巧数组/单链表单链表常考双指针 数组常用的技巧很大一部分还是双指针相关的技巧： 二分搜索 只能用在有序数组上 滑动窗口算法 典型的快慢双指针，快慢指针中间就是滑动的窗口，主要用于解决子串问题 限制：明确知道什么时候扩大窗口，什么时候收缩窗口 回文串 判断是否是回文：双指针从两边向中间检查 找回文子串：从中心向两端扩散 寻找最长回文子串：马拉车算法(Manacher)，不过性价比不高，没必要掌握 前缀和 如果需要频繁计算子数组的和，可以用for循环，但利用前缀和预计算preSUm数组，可以避免循环 差分数组 如果频繁对子数组进行增减，可以用for循环，但用差分数组diff去维护，可以避免循环 二叉树二叉树很重要，几乎是所有高级算法的基础！！ 二叉树的递归解法可以分成两类思路： 遍历一遍二叉树得出答案–》回溯算法 通过分解问题计算出答案–》动态规划 动态规划问题有【最优子结构】和【重叠子问题】两个特性，而且大多都是让求最值的。很多算法虽然不属于动态规划，但也符合分解问题的思维模式。 常用算法：动归、回溯（DFS）、分治、BFS","link":"/2022/04/19/%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%92%8C%E5%88%B7%E9%A2%98%E7%9A%84%E6%A1%86%E6%9E%B6%E6%80%9D%E7%BB%B4/"},{"title":"pip问题汇总","text":"记录pip安装时遇到的问题以及解决办法。 镜像配置pip install 的时候如果不用镜像很可能因为网络error报错，使用镜像也可以让安装速度快很多。下面是使用镜像的方法。 1pip3 install pmdarima -i https://pypi.tuna.tsinghua.edu.cn/simple 一些其他开源镜像 1234清华大学：https://pypi.tuna.tsinghua.edu.cn/simple中国科学技术大学 : https://pypi.mirrors.ustc.edu.cn/simple豆瓣：http://pypi.douban.com/simple/阿里云：http://mirrors.aliyun.com/pypi/simple/","link":"/2022/08/22/pip%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"Book","slug":"Book","link":"/tags/Book/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Website","slug":"Website","link":"/tags/Website/"},{"name":"Fucking-algorithm","slug":"Fucking-algorithm","link":"/tags/Fucking-algorithm/"},{"name":"Bug","slug":"Bug","link":"/tags/Bug/"}],"categories":[{"name":"Coding","slug":"Coding","link":"/categories/Coding/"},{"name":"Algorithm","slug":"Coding/Algorithm","link":"/categories/Coding/Algorithm/"},{"name":"Reading","slug":"Reading","link":"/categories/Reading/"},{"name":"Web","slug":"Coding/Web","link":"/categories/Coding/Web/"}]}