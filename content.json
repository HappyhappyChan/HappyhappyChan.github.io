{"pages":[],"posts":[{"title":"Create My Website","text":"My Blog URL部署链接：https://happyhappychan.github.io/ 本地测试链接：http://localhost:4000/ Blog Framework使用的是知乎上推荐很多的Blog Framework——Hexo Preparation在使用Hexo之前，需要安装好Node.js和npm Node.js 简单的说 Node.js 就是运行在服务端的 JavaScript。 Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。 由于Node.js平台是在后端运行JavaScript代码，所以，必须首先在本机安装Node环境。 Node.js 是能够在服务器端运行 JavaScript 的开放源代码、跨平台执行环境.from wiki npm npm其实是Node.js的包管理工具（package manager） 为啥我们需要一个包管理工具呢？因为我们在Node.js上开发时，会用到很多别人写的JavaScript代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生：大家都把自己开发的模块打包后放到npm官网上，如果要使用，直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。 更重要的是，如果我们要使用模块A，而模块A又依赖于模块B，模块B又依赖于模块X和模块Y，npm可以根据依赖关系，把所有依赖的包都下载下来并管理起来。否则，靠我们自己手动管理，肯定既麻烦又容易出错。 Test npm 12C:\\Users\\MagicKD&gt;npm -v8.5.0 Test Node.js 12C:\\Users\\MagicKD&gt;node -vv16.14.2 Tutorial具体使用 Hexo和GitHub搭建的网页参考了知乎分享的教程GitHub+Hexo 搭建个人网站详细教程 值得注意的是，这篇教程有点历史了，所以有些操作描述不太正确，记得看评论区！ 1 Install HexoHexo官网说的是 1$ npm install -g hexo-cli 但是，用上面那种方法，根本下载不下来，因此要修改镜像。修改方法如下： 这里是通过命令行临时指定镜像的方式 1npm install -g hexo-cli --registry=https://registry.npm.taobao.org 参考链接：修改npm镜像 2 Init Blog 第一步，先找个地方创建存放blog的文件夹 1F:\\github_data\\Github_Blogs 第二步，找到代理端口7890 我是从clash for windows 上查看的 第三步，设置代理 在git bash或者cmd控制台输入git config –global http.proxy localhost:7890上面xxxx输入自己代理端口号，四位数，输入在执行hexo init 命令就好了，下面图片是我看到·的解决办法，极大的帮助了我 取消全局代理的命令：git config –global –unset http.proxy 别人说这个方法不行，一开始设置了代理，现在要取消全局代理，然后就按照上面的命令取消了全局代理。 第四步，直接hexo init 上面的2 3 都失败后【已经根据命令取消全局代理了】，就打算开着clash for windows 和 paofucloud，在下面这个状态下直接 hexo init，挂一个晚上。 结果，上个厕所回来打算睡觉的时候，发现成功了！ 第五步，测试环境 12345MagicKD@LAPTOP-M9O0BF78 MINGW64 /f/github_data/Github_Blogs$ hexo sINFO Validating configINFO Start processingINFO Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop. 第六步，下载喜欢的模板 1234567MagicKD@LAPTOP-M9O0BF78 MINGW64 /f/github_data/Github_Blogs$ cnpm install√ Installed 10 packages√ Linked 0 latest versions√ Run 0 scripts√ All packages installed (used 42ms(network 39ms), speed 0B/s, json 0(0B), tarball 0B, manifests cache hit 0, etag hit 0 / miss 0) 12MagicKD@LAPTOP-M9O0BF78 MINGW64 /f/github_data/Github_Blogs$ git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus --depth 1 第七步，配置环境 123MagicKD@LAPTOP-M9O0BF78 MINGW64 /f/github_data/Github_Blogs$ hexo config theme icarusINFO Validating config 第八步，测试模板 1234567891011121314151617MagicKD@LAPTOP-M9O0BF78 MINGW64 /f/github_data/Github_Blogs$ hexo serverINFO Validating configInferno is in development mode.INFO ======================================= ██╗ ██████╗ █████╗ ██████╗ ██╗ ██╗███████╗ ██║██╔════╝██╔══██╗██╔══██╗██║ ██║██╔════╝ ██║██║ ███████║██████╔╝██║ ██║███████╗ ██║██║ ██╔══██║██╔══██╗██║ ██║╚════██║ ██║╚██████╗██║ ██║██║ ██║╚██████╔╝███████║ ╚═╝ ╚═════╝╚═╝ ╚═╝╚═╝ ╚═╝ ╚═════╝ ╚══════╝=============================================INFO === Checking package dependencies ===INFO === Checking theme configurations ===INFO === Registering Hexo extensions ===INFO Start processingINFO Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop. 3 Publish 1 配置站点文件 在blog根目录里的_config.yml文件称为站点配置 进入根目录里的themes文件夹，里面也有个_config.yml文件，这个称为主题配置文件 下一步将我们的Hexo与GitHub关联起来，打开站点的配置文件_config.yml，翻到最后修改为： deploy:type: gitrepo: 这里填入你之前在GitHub上创建仓库的完整路径，记得加上 .gitbranch: master参考如下： 1234deploy: type: git repo: https://github.com/HappyhappyChan/HappyhappyChan.github.io.git branch: master 2 安装Git部署插件 最后安装Git部署插件, 123456789MagicKD@LAPTOP-M9O0BF78 MINGW64 /f/github_data/Github_Blogs$ npm install hexo-deployer-git --saveadded 1 package, and audited 447 packages in 4s28 packages are looking for funding run `npm fund` for detailsfound 0 vulnerabilities 发现直接上面完成直接进入第三步会失败，于是用cnpm再安装一次 1cnpm install hexo-deployer-git --save 3 Hexo 实现部署 1234hexo cleanhexo generatehexo deploy# 以上3条命令依次执行 ==尝试1==失败 在部署的时候一直显示login fail, 怀疑是验证失败，然后根据这个链接生成一个personal token ghp_xyA4B6xWI……【2022-04-12 有效期30天，看github_data/git.txt】 ==尝试2==成功deploy 参考hexo-d失败的解决方法 123456789101112131415161718192021C:\\Users\\MagicKD&gt;ssh-keygen -t rsa -C &quot;1214999431@qq.com&quot;Generating public/private rsa key pair.Enter file in which to save the key (C:\\Users\\MagicKD/.ssh/id_rsa):Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in C:\\Users\\MagicKD/.ssh/id_rsa.Your public key has been saved in C:\\Users\\MagicKD/.ssh/id_rsa.pub.The key fingerprint is:SHA256:ClY/3TSwdHuDiFZjcNARA9NiBaOt7jMCV/lm11mfee4 1214999431@qq.comThe key's randomart image is:+---[RSA 2048]----+| BO%o. || ooOoB o || oo+.o = o || .o+ . o o.. || o...S ...o .o|| ...o .+.. o oo|| o oo . ..|| ..o .|| ..o .E|+----[SHA256]-----+ 配置站点文件 12345deploy: type: git #repo: https://github.com/HappyhappyChan/HappyhappyChan.github.io.git repo: git@github.com:HappyhappyChan/HappyhappyChan.github.io.git branch: master 1234deploy: type: git repo: git@github.com:HappyhappyChan/HappyhappyChan.github.io.git branch: main Github Page 404如果前面都运行正常，结果还是pages 404。 这应该是浏览器缓存的问题，我用的是360浏览器，点击右上角工具，然后点击清除上网痕迹，即可解决。 另一个办法是换一个浏览器访问。 我的解决方法：一开始一直用Chrome， 然后换了搜狗浏览器，就可以正常打开了。 Hexo Command123456789101112131415npm install hexo -g #安装Hexonpm update hexo -g #升级hexo init #初始化博客命令简写hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令 Debug然后打开cmd，采用管理员方式，进入 Github_Blogs，在命令行输入 1hexo init 发现npm还是太慢了，于是下载cnpm 1npm install -g cnpm --registry=https://registry.npm.taobao.org 测试cnpm是否安装成功 123456789cnpm -vC:\\Users\\MagicKD&gt;cnpm -vcnpm@7.1.1 (C:\\Users\\MagicKD\\AppData\\Roaming\\npm\\node_modules\\cnpm\\lib\\parse_argv.js)npm@6.14.16 (C:\\Users\\MagicKD\\AppData\\Roaming\\npm\\node_modules\\cnpm\\node_modules\\npm\\lib\\npm.js)node@16.14.2 (F:\\Node-js-16.14.2x64\\node.exe)npminstall@5.8.0 (C:\\Users\\MagicKD\\AppData\\Roaming\\npm\\node_modules\\cnpm\\node_modules\\npminstall\\lib\\index.js)prefix=C:\\Users\\MagicKD\\AppData\\Roaming\\npmwin32 x64 10.0.18362registry=https://registry.npmmirror.com 使用cnpm 1cnpm info underscore hexo init 要在管理员身份下进行？ 1hexo init blog 12hexo init blog --registry=https://registry.npm.taobao.org# 这个试过也不行…… ReferenceHexo部署 Hexo+Github: 个人博客网站搭建完全教程 搭建个人博客网站教程","link":"/2022/04/12/Create-My-Website/"},{"title":"1.1 数组链表","text":"Preface这部分是有关数组和链表的算法，包括：前缀和、差分数组、双指针、滑动窗口、二分搜索、递归、田忌赛马等。 关于基础数据结构基础数据结构包括：数组、链表、队列、栈等，因为都比较类似、操作过程不怎么涉及递归，所以都归纳成较为基础的数据结构 数组/链表数组、链表代表计算机最基本的两种存储形式：顺序存储、链式存，因此也是最基本的数据结构。 数组链表的主要算法技巧： 双指针 中间向两端扩散的双指针 两端向中间收缩的双指针、快慢指针 前缀和技巧 差分数组技巧 前缀和数组题目LeetCode：303、304、560 应用适用于快速、频繁地计算一个索引区间内的元素之和 核心代码1234567891011121314class PrefixSum{ private int[] prefix; public PrefixSum(int[] nums){ prefix = new int[nums.length+1]; for(int i = 1; i &lt; prefix.length; i++){ prefix[i] = prefix[i-1]+nums[i-1]; } } /* 闭区间[i, j] 的累加和*/ public int query(int i, int j){ return prefix[j+1]-prefix[i]; }} 差分数组题目370， 1109， 1094 应用频繁对原始数组的某个区间的元素进行增减 例子 我给你输⼊⼀个数组 nums，然后⼜要求给区间 nums[2..6] 全部加 1，再给 nums[3..9] 全部减 3，再给 nums[0..4] 全部加 2，再给… 问最后 nums 数组的值是什么？ 框架构造一个diff差分数组，diff[i] 就是 nums[i]-nums[i-1] 123456int[] diff = new int[nums.length];//构造差分数组diff[0] = nums[0];for(int i = 1; i &lt; nums.length; i++){ diff[i] = nums[i] - nums[i-1];} 利用差分数组diff反推出原始数组nums： 123456int[] res = new int[diff.length];//根据差分数组构造结果数组res[0] = diff[0];for(int i = 1; i &lt; diff.length; i++){ res[i] = res[i-1] + diff[i];} 如果想对区间nums[i..j]的元素全部加3，只要让diff[i] += 3， 然后再让diff[j+1] -= 3即可 原理很简单，回想 diff 数组反推 nums 数组的过程，diff[i] += 3 意味着给 nums[i..] 所有的元素都 加了 3，然后 diff[j+1] -= 3 ⼜意味着对于 nums[j+1..] 所有元素再减 3，那综合起来，是不是就是对 nums[i..j] 中的所有元素都加 3 了？ 只要花费 O(1) 的时间修改 diff 数组，就相当于给 nums 的整个区间做了修改。多次修改 diff，然后通过 diff 数组反推，即可得到 nums 修改后的结果 1234567891011121314151617181920212223242526272829303132class Difference{ //差分数组 private int[] diff; /*输入一个初始数组，区间操作将在这个数组上进行*/ public Difference(int[] nums){ assert nums.length &gt; 0; diff = new int[nums.length]; diff[0] = nums[0]; for(int i = 1; i &lt; nums.length; i++){ diff[i] = nums[i] - nums[i-1]; } } /*给闭区间[i,j]增加val (val可以为负)*/ public void increment(int i, int j, int val){ diff[i] += val; if(j + 1 &lt; diff.length){ diff[j+1] -= val; } } /*返回结果数组*/ public int[] result(){ int[] res = new int[diff.length]; res[0] = diff[0]; for(int i = 1; i &lt; diff.length; i++){ res[i] = res[i-1] + diff[i]; } return res; }} 当 j+1 &gt;= diff.length 时，说明是对 nums[i] 及以后的整个数组都进⾏修改，那么就不需要再给 diff 数组减 val 了。 双指针技巧秒杀链表题目21、23、141、142、876、19、160 应用单链表常见算法题： 合并两个有序链表 合并k个有序链表 寻找单链表的倒数第k个节点 寻找单链表的中点 判断单链表是否包含环并找出环起点 判断两个单链表是否相交并找出交点 上述都用到了双指针技巧 框架合并两个有序链表这个算法的逻辑类似于【拉拉链】，l1, l2 类似拉链两侧的锯齿，p就像拉链的拉索，将两个有序链表合并。 链表的算法题中常见的技巧：虚拟头结点，也就是dummy结点。 123456789101112131415161718192021222324252627ListNode mergeTwoLists(ListNode l1, ListNode l2){ //虚假头结点 ListNode dummy = new ListNode(-1), p = dummy; ListNode p1 = l1, p2 = l2; while(p1 != null &amp;&amp; p2 != null){ //比较p1 p2两个指针 //将小的节点接在p指针后面 if(p1.val &gt; p2.val){ p.next = p2; p2 = p2.next; }else{ p.next = p1; p1 = p1.next; } p = p.next; } if(p1 != null){ p.next = p1; } if(p2 != null){ p.next = p2; } return dummy.next;} 合并k个有序链表难点：如何快速得到k个结点中的最小结点，接到结果链表上。 解决：使用优先级队列（二叉堆），把链表结点放入一个最小堆，就可以每次获得k个结点中的最小结点。 1234567891011121314151617181920212223242526ListNode mergeKLists(ListNode[] lists){ if(lists.length == 0) return null; //虚拟头结点 ListNode dummy = new ListNode(-1); ListNode p = dummy; //优先级队列，最小堆 PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;( lists.length, (a, b) -&gt; (a.val - b.val)); //将k个链表的头结点加入最小堆 for(ListNode head: lists){ if(head != null) pq.add(head); } while(!pq.isEmpty()){ //获取最小结点，接到结果链表中 ListNode node = pq.poll(); p.next = node; if(node.next != null){ pq.add(node.next); } //p指针不断前进 p = p.next; } return dummy.next;} 复杂度分析： 优先队列pq中的元素个数最多是k， 所以一次 poll 或者 add 的时间复杂度是O(logk) 所有链表的节点都会被加入和弹出pq， 所以算法整体的时间复杂度是O(Nlogk)，其中k是链表的条数， N是这些链表的节点总数 单链表的倒数第k个结点 最暴力的方法：【两次遍历】 先从头遍历得出链表长度，然后再次遍历计算得到第 n-k+1个节点 双链表解法：【双指针一次遍历】 先让指针p1指向链表的头结点head，走k步；此时p1只用再走n-k步，就可以走到链表末尾的空指针 然后让指针p2指向链表头结点head 123456789101112131415ListNode findFromEnd(ListNode head, int k){ ListNode p1 = head; //p1 先走k步 for(int i = 0; i &lt; k; i++){ p1 = p1.next; } ListNode p2 = head; // p1 p2同时走 n-k 步 whle(p1 != null){ p2 = p2.next; p1 = p1.next; } //p2 现在指向第n-k个结点 return p2;} 时间复杂度分析 用big O表示法来计算时间复杂度，遍历1次or2次时间复杂度都是O(N)，但是这个算法更有技巧性。 注意 不过注意我们使用了虚拟头结点的技巧，也是为了防止出现空指针的情况，比如说链表总共有 5 个节点， 题⽬就让你删除倒数第 5 个节点，也就是第⼀个节点，那按照算法逻辑，应该⾸先找到倒数第 6 个节点。但 第⼀个节点前面已经没有节点了，这就会出错。但有了我们虚拟节点 dummy 的存在，就避免了这个问题，能够对这种情况进行正确的删除。 单链表的中点对应LeetCode 876 暴力 先遍历链表计算链表长度n，然后再遍历一次得到第n/2个结点 快慢指针 慢指针走1步，快指针走2步，快指针走到末尾，慢指针就走到了中点. 当链表长度为偶数时，返回的节点是靠后的节点。 123456789ListNode middleNode(ListNode head){ //快慢指针初始化指向head ListNode slow = head, fast = head; while(fast != null &amp;&amp; fast.next != null){ slow = slow.next; fast = fast.next.next; } return slow;} 判断链表是否包含环 快慢指针 slow走1步，fast走2步，如果fast最终遇到空指针，说明没有环，如果fast和slow最终相遇，说明fast超过slow一圈，说明链表中有环。 题目：141 easy 12345678910111213boolean hasCycle(ListNode head){ //快慢指针初始化指向head ListNode slow = head, fast = head; //快指针走到末尾时停止 while(fast != null &amp;&amp; fast.next != null){ //慢指针走一步，快指针走2步 slow = slow.next; fast = fast.next.next; if(slow == fast) return true; } return false;} 判断环的起点 题目：142 Medium 解析 我们假设快慢指针相遇时，慢指针 slow 走了 k 步，那么快指针 fast 一定走了 2k 步。 这多走的k步其实就是在环里面转圈，所以k的值就是环长度的整数倍。 假设相遇点距环的起点距离为m，慢指针走了k步，则环起点距离head有k-m步。所以从相遇点开始走k步就可以转回到相遇点，走k-m步就是走到环起点。 12345678910111213141516171819202122ListNode detectCycle(ListNode head){ ListNode fast, slow; fast = slow = head; while(fast != null &amp;&amp; fast.next != null){ fast = fast.next.next; slow = slow.next; if(slow = fast) break; } if(fast == null || fast.next == null) //说明没有环 return null; //重新指向头结点 slow = head; //快慢指针同步进行，相交点就是环起点 while(slow != fast){ fast = fast.next; slow = slow.next; } return slow;} 两个链表是否相交 题目：160 暴力法： 用HastSet记录一个链表的所有结点，然后和另一条链表对比，这需要额外空间 双指针： 让p1遍历完A链表，之后开始遍历B链表。 让p2遍历完B链表后开始遍历A链表，这样逻辑上连接在一起。 这样拼接可以使p1 p2同时进入公共部分，达到交点。 如果没有交点，返回null 1234567891011121314151617181920212223242526ListNode getIntersectionNode(ListNode heada, ListNode headb){ //p1 指向 A链表头结点，p2指向B链表头结点 ListNode p1 = head1, p2 = headb; while(p1 != p2){ //p1 走一步，如果走到A链表末尾，转到B链表 if(p1 == null){ p1 = headb; }else{ p1 = p1.next; } //p2 走1步，如果走到B链表末尾，转到A链表 if(p2 == null){ p2 = heada; }else{ p2 = p2.next; } } return p1; //上面也可以变成 while(p1 != p2){ p1 = p1 == null ? headB : p1.next; p2 = p2 == null ? headA : p2.next; } return p1;} 注意：判断条件一定是p1 or p2 == null? 而不是p1.next or p2.next == null吗，否则会出现不相交，然后一直在while里面死循环的情况。 复杂度 空间复杂度O(1)，时间复杂度O(N) 转换成环的问题：将两条链表首尾相连，转换成求环起点问题 1234567891011121314151617181920212223242526272829ListNode getIntersectionNode(ListNode heada, ListNode headb){ int lena = 0, lenb = 0; //计算两条链表长度 for(ListNode p1 = heada; p1 != null; p1 = p1.next){ lena++; } for(ListNode p2 = headb; p2 != null; p2 = p2.next){ lenb++; } //让p1 和 p2达到尾部距离相同 ListNode p1 = heada, p2 = headb; if(lena &gt; lenb){ for(int i = 0; i &lt; lena - lenb; i++){ p1 = p1.next; } }else{ for(int i = 0; i &lt; lenb - lena; i++){ p2 = p2.next; } } //看两个指针是否会相同,p1==p2时有两种情况 // 1 两条链表不相交，同时走到尾部空指针 // 2 要是两条链表相交，走到两个链表的相交点 while(p1 != p2){ p1 = p1.next; p2 = p2.next; } return p1;} 虽然代码多一些，时间复杂度还是O(N) 双指针技巧秒杀数组题目26、83、27、283、167、344、5 在处理数组和链表的时候，双指针技巧经常使用，主要技巧分为两类：左右指针和快慢指针。 左右指针：两个指针相向而行或相背而行 快慢指针：两个指针同向而行，一快一慢 对单链表来说，大部分技巧属于快慢指针。 在数组中没有真正意义上的指针，所以可以把索引当做数组中的指针，这样也可以在数组中施展双指针。 快慢指针技巧场景：数组问题中比较常见且难度不高的快慢指针技巧，是让你原地修改数组。 题目： 26 删除有序数组中的重复项 83 删除排序链表中的重复元素 27 移除元素 注意！不要忘了先判断最简单的情况！ 12if (nums.length == 0) return 0; if (head == null) return null; 滑动窗口算法1234567891011121314151617181920//滑动窗口算法框架void slidingWindow(string s, string t){ unordered_map&lt;char, int&gt; need, window; for(char c: t) need[c]++; int left = 0, right = 0; int valid = 0; while(right &lt; s.size()){ char c = s[right]; //右移增大窗口 right++; //进行窗口内数据的一系列更新 while(window needs shrink){ char d = s[left]; //左移缩小窗口 left++; //进行窗口内数据的一系列更新 } }} 左右指针的常用算法二分查找前提条件：有序！ 由于其他地方有详细探讨二分搜索代码的细节问题，这里只写最简单的二分算法，旨在突出他双指针的特性 1234567891011121314int binarySearch(int[] nums, int target){ //一左一右两个指针相向而行 int left = 0, right = nums.length - 1; while(left &lt;= right){ int mid = (right + left)/2; if(nums[mid] == target) return mid; else if(nums[mid] &lt; target) left = mid+1; else if(nums[mid] &gt; target) right = mid-1; } return -1;} 两数之和题目：167 两数之和 反转数组题目：344 反转字符串 5 最长回文子串 判断是否是回文串：从两边向中间 123456789101112boolean isPalindrome(String s){ //一左一右两个指针相向而行 int left = 0, right = s.length() - 1; while(left &lt; right){ if(s.charAt(left) != s.charAt(right)){ return false; } left++; right--; } return true;} 寻找回文串，从中间向两边 回文串的长度可能是奇数也可能是偶数，所以解决问题的核心是从中心向两端扩散。 如果回文串长度是奇数，则有一个中心字符；如果是偶数，则有2个中心字符，因此可以先实现这样一个函数 12345678910//在S中寻找以s[l] s[r]为中心的最长回文串String palindrome(String s, int l, int r){ //防止索引越界 while(l &gt;= 0 &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r)){ l--; r++; } //返回s[l] 和 s[r]为中心的最长回文串 return s.substring(l+1, r);} 滑动窗口题目76 最小覆盖子串 hard 567 字符串排列 medium 438 Find All Anagrams in a String 找到字符串中所有字母异位词 medium 3 Longest Substring Without Repeating Character 最长无重复子串 medium ：如果说只有字母那可以用数组，但是没说就可能包含特殊符号，还是要用hashmap 技巧顺口溜123456789链表子串数组题，使用双针别犹豫快慢指针最神奇，链表操作无压力归并排序找中点，链表成环搞判定左右指针最常见，左右两端相向行反转数组要靠他，二分搜索是弟弟滑动窗口要背下，子串问题全靠他 框架算法思路：维护一个窗口，不断滑动 时间复杂度：O(N) 算法逻辑： 123456789101112int left = 0, right = 0;while(right &lt; s.size()){ // 增大窗口 window.add(s[right]); right++; while(window needs shrink){ //缩小窗口 window.remove(s[left]); left++; }} 算法框架： 1234567891011121314151617181920212223242526272829//滑动窗口算法框架void slidingWindow(String s, String t){ unordered_map&lt;char, int&gt; need, window; for(char c: t) need[c]++; int left = 0, right = 0; int valid = 0; while(right &lt; s.size()){ //c是将移入窗口的字符 char c = s[right]; //增大窗口 right++; //进行窗口内数据的一系列更新 // ... 更新窗口数据【扩大窗口】 //debug 输出位置 printf(&quot;window:[%d, %d]\\n&quot;, left, right); //判断左窗口是否要收缩 while(window needs shrink){ //d是将移出窗口的字符 char d = s[left]; //缩小窗口 left++; //进行窗口内数据的一系列更新 //... 更新窗口数据【缩小窗口】 } }} 上面的代码是用cpp实现的，下面解释一下： unorder_map 就是哈希表（字典），相当于 HashMap， 他的一个方法count(key)相当于java的containsKey(key) 可以判断key是否存在 可以使用方括号访问键对应的值map[key]。需要注意的是，可以这个key不存在，cpp会自动创建这个key，然后把map[key]的值赋值0。所以代码中多次出现的map[key]++相当于Java的map.put[key, map.getOrDefault(key,0)+1] 另外，Java中的integer和String这种包装类不能直接用==进行相等判断，而应该使用类的equals方法。 二分搜索题目704 Binary Search Easy 34 Find First and Last Position of Element in Sorted Array 应用【前提】有序数组 二分查找思路简单，细节是魔鬼。很多人喜欢拿整型溢出的bug说事，但二分查找真正的坑在于到底要给mid加一还是减一，while里到底用&lt;=还是&lt;。 寻找一个数 寻找左边界 寻找右边界 技巧顺口溜管他左侧还是右侧，搜索区间定乾坤 搜索一个元素时，搜索区间两端闭，while条件带等号，否则就要出问号。遇到if相等就返回，其他事情别操心。mid必须加减1，因为区间两端闭，while结束返-1。 搜索左右边界时，搜索区间要阐明，左闭右开最常见，while要用小于号，if相等别返回，利用mid锁边界，mid加减看开闭。while结束不算完，因为你还没返回，索引可能出边界，要用if来check check。 二分查找框架1234567891011121314int binarySearch(int[] nums, int target){ int left = 0, right = ...; while(...){ int mid = left + (right - left)/2; if(nums[mid] == target){ ... }else if(nums[mid] &lt; target){ left = ... }else if(nums[mid] &gt; target){ right = ... } } return ...;} 分析二分查找的一个技巧是：不要出现else，把所有情况用else if写清楚，这样可以清楚地展示所有的细节。 上面代码中…标记的部分，就是可能出现细节问题的地方，但你遇到一个二分查找的代码，首先注意这几个地方。 计算mid的时候要防止溢出，代码中left+(right-left)/2和(left+right)/2结果相同，但是有效防止了left right太大，直接相加导致溢出的情况。 寻找一个数(基本的二分搜索)搜索一个数，如果存在返回其索引，否则返回-1 12345678910111213141516int binarySearch(int[] nums, int target){ int left = 0; int right = nums.length - 1; //注意 while(left &lt;= right){ int mid = left + (right - left)/2; if(nums[mid] == target) return mid; else if(nums[mid] &lt; target){ left = mid + 1; }else if(nums[mid] &gt; target){ right = mid - 1; } } return -1;} while中循环条件是&lt;=而不是&lt; 因为初始化中right的赋值是nums.length - 1, 即最后一个元素的索引，而不是nums.length; 前者相当于两端都闭区间[left, right]，后者相当于左闭右开区间[left, right)，因为索引大小为 nums.length是越界的 这里采用[left, right]两端都闭，这个区间其实就是每次进行搜索的区间 何时停止搜索 搜索区间为空的时候。while(left &lt;= right)的终止条件是left == right +1 ，即[right + 1, right]。这时while循环结束，直接返回-1即可 while(left &lt; right)的终止条件是left == right，写成区间的形式是[right, right]，比如[2,2]，这时候区间非空，还有一个数2，如果此时就终止勋魂，2没有被搜索，直接返回-1是错的。 如果非要用while(left &lt; right)，修改成下面jike 1return nums[left] == target? left : -1; 关于left = mid + 1, right = mid -1 本算法采用的搜索区间是两端都闭，所以当发现mid不是要找的数时，直接去+1 or -1搜索即可 算法缺陷 比如 nums=[1,2,2,3]，要找的数是2，此算法返回的索引是2.但是如果要找到目标的左边界 1， 右边界2，无法处理。 当然可以找到一个target，然后左右线性搜索，是可行，但是无法保证二分查找对数级的复杂度。 寻找左侧边界的二分查找1234567891011121314151617int left_bound(int[] nums, int target){ if(nums.length == 0) return -1; int left = 0; int right = nums.length; //注意 while(left &lt; right){//注意 int mid = left + (right - left)/2; if(nums[mid] == target){ right = mid; }else if(nums[mid] &lt; target){ left = mid + 1; }else if(nums[mid] &gt; target){ right = mid; } } return left;} while中是&lt;而不是&lt;= 因为用相同的方法分析，因为right = nums.length 而不是 nums.length - 1，因此每次循环的搜索区间是[left, right)左闭右开 while循环的终止条件是left == right， 此时搜索区间[left, left)为空，所以可以正确终止 返回值为什么没有-1 函数的返回值即left变量的值取值区间是闭区间[0, nums.length]，所以简单添加两行代码就可以在正确的时候return -1; 1234567while(left &lt; right){ //...}//target 比所有数都大if(left == nums.length) return -1;//类似之前算法的处理方法return nums[left] == target? left : -1; 为什么left = mid + 1, right = mid 因为搜索区间是左闭右开，当mid被检测之后，下一步应该去mid的左侧或右侧区间搜索，即[left, mid)或[mid+1, right) 返回left不是right？ 其实都一样的，因为while的终止条件是 left == right 把right也变成nums.length - 1 因为while的退出条件是left = right + 1, 所以当target比nums中所有元素都大时，会存在left索引越界的情况 12345678910111213141516171819int left_bound(int[] nums, int target){ //搜索区间为[left, right] int left = 0, right = nums.length - 1; while(left &lt;= right){ int mid = left + (right - left)/2; if(nums[mid] &lt; target){ left = mid + 1; }else if(nums[mid] &gt; target){ right = mid - 1; }else if(nums[mid] == target){ //数据右侧边界 right = mid - 1; } } //检查出界情况 if(left &gt;= nums.length || nums[left] != target) return -1; return left;} 寻找右侧边界的二分查找这里还是常见的左闭右开的写法 123456789101112131415int right_bound(int[] nums, int target){ if(nums.length==0) return -1; int left = 0, right = nums.length; while(left &lt; right){ int mid = left + (right - left)/2; if(nums[mid] == target){ left = mid + 1; //注意 }else if(nums[mid] &lt; target){ left = mid + 1; }else if(nums[mid] &gt; target){ right = mid; } } return left - 1; //注意} 要返回-1 12345while(l &lt; r){ // ...}if(l == 0) return -1;return nums[l - 1] == target? (l - 1): -1; 逻辑统一12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152int binary_search(int[] nums, int target){ int l = 0, r = nums.length - 1; while(l &lt;= r){ int mid = l + (r - l)/2; if(nums[mid] == target){ return mid; }else if(nums[mid] &lt; target){ l = mid + 1; }else if(nums[mid] &gt; target){ r = mid - 1; } } return -1;}int left_bound(int[] nums, int target){ if(nums.length == 0) return -1; int l = 0, r = nums.length; while(l &lt; r){ int mid = l + (r - l)/2; if(nums[mid] == target){ r = mid; }else if(nums[mid] &lt; target){ l = mid + 1; }else if(nums[mid] &gt; target){ r = mid; } } if(l &gt;= nums.length || nums[l] != target){ return -1; } return l;}int right_bound(int[] nums, int target){ if(nums.length == 0) return -1; int l = 0, r = nums.length; while(l &lt; r){ int mid = l + (r - l)/2; if(nums[mid] == target){ l = mid + 1; }else if(nums[mid] &lt; target){ l = mid + 1; }else if(nums[mid] &gt; target){ r = mid; } } if(l == 0 || nums[l-1] != target){ return -1; } return l - 1;} 二分搜索套路分析题目875 Koko Eating Bananas medium 1011 Capacity To Ship Packages Within D Days medium lock 应用算法题一般都让你求最值，比如求吃东西的最小速度，轮船的最低运载能力，求最值的过程必然是一个搜索边界的过程。 【二分搜索问题的泛化】要从题目中抽象出一个自变量x，一个关于x的函数f(x)，以及一个目标值target. 要满足以下条件： f(x)必须是在x上的单调函数（单调增单调减都可以） 题目是让你计算满足约束条件f(x)==target时的x值 框架运用二分搜索解决具体问题的算法 12345678910111213141516171819202122232425262728//函数f是关于自变量x的单调函数int f(int x){ }//主函数 在f(x)==target的约束下求x的最值int solution(int[] nums, int target){ if(nums.length == 0) return -1; //问自己 自变量x的最小值是多少 int left = ...; //问自己：自变量x的最大值是多少 int right = ... + 1; while(left &lt; right){ int mid = left + (right - left)/2; if(f(mid) == target){ //问自己：题目求左边界还是右边界 //... }else if(f(mid) &lt; target){ //问自己，怎么让f(x)大一点 //... }else if(f(mid) &gt; target){ //问自己：怎么让f(x)小一点 //... } } return left;} 田忌赛马背后的算法题目870 Advantage Shuffle medium 思路打得过就打，打不过就拿自己的垃圾和对方精锐互换 框架12345678910111213int n = nums1.length;sort(nums1); //田忌的马sort(nums2); //齐王的马//从最快的马开始比for(int i = n - 1; i &gt;= 0; i--){ if(nums1[i] &gt; nums2[i]){ //比得过跟他比 }else{ //比不过 换个垫底的来送人头 }} 链表递归题目206 Reverse Linked List Easy 92 Reverse Linked List II medium 框架递归反转整个链表12345678ListNode reverse(ListNode head){ if(head == null || head.next == null) return head; ListNode last = reverse(head.next); head.next.next = head; head.next = null; return last;} 非递归写法 12345678910111213public ListNode reverseList(ListNode head) { if(head == null || head.next == null) return head; ListNode phead = new ListNode(-1); ListNode cur = head; while(cur != null){ ListNode tmp = cur.next; cur.next = phead.next; phead.next = cur; cur = tmp; } return phead.next; } 反转链表的前N个节点12345678910111213141516ListNode successor = null; //后驱节点//反转以head 为起点的n个节点，返回新的头结点ListNode reverseN(ListNode head, int n){ if(n == 1){ //记录第n+1个节点 successor = head.next; return head; } //以head.next为起点，需要反转前n-1个节点 ListNode last = reverseN(head.next, n-1); head.next.next = head; //让反转之后的head节点和后面的节点连起来 head.next = successor; return last;} 反转链表的一部分索引从1开始，如果 m=1，则相当于反转链表开头的n个元素 12345678ListNode reverseBetween(ListNode head, int m, int n){ //base case if(m == 1) return reverseN(head, n); //前进到反转的起点触发base case head.next = reverseBetween(head.next, m-1, n-1); return head;} 小结递归和迭代的时间复杂度都是O(N)，但是迭代的空间复杂度是O(1)，递归需要用到栈，空间复杂度是O(N)。 所以考虑效率的话还是迭代算法比较好","link":"/2022/04/19/1.1%20%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/04/12/hello-world/"},{"title":"Hexo Theme Modification: Icarus","text":"Preface花了不少功夫配置网站，到今天终于搞的差不多啦，就拿这一篇大致记录一下如何配置 Hexo Theme 中的 Icarus 5.0.0 version~ 参考了Reference里面的许多代码，但是个别代码有问题，所以不能单纯的ctrl+v/c，遇到问题根据vscode报错好好debug。Icarus不同版本代码有挺大差别的，Icon的选取也要注意是不是pro / free。 个性化配置logo_config.icarus.yml 12345logo: /img/crayon-shinchan-logo.svg # text: HappyhappyChan's Bloghead: favicon: /img/crayon-shinchan-logo.svg Avatar_config.icarus.yml 123avatar: /img/Himawali.png avatar_rounded: True #false gravatar: #chenlh65@mail2.sysu.edu.cn gravatar如果不为空，会优先指向这个对应的链接。如果为空，就取avatar里面的地址 导航栏_config.icarus.yml 1234567891011121314151617181920212223navbar: menu: Home: / Archives: /archives Categories: /categories Tags: /tags About: /about links: Fork me on GitHub: icon: fab fa-github url: https://github.com/HappyhappyChanarticle: highlight: # 代码高亮主题 # https://github.com/highlightjs/highlight.js/tree/master/src/styles theme: atom-one-light # 显示复制代码按钮 clipboard: true # 代码块的默认折叠状态。可以是&quot;&quot;, &quot;folded&quot;, &quot;unfolded&quot; fold: unfolded readtime: true update_time: auto #设置为false来隐藏所有文章的更新时间，或设置为auto而在文章的更新时间 与发布时间相同时隐藏更新时间 licenses: Footer_config.icarus.yml 1234567891011footer: links: Creative Commons: icon: fab fa-creative-commons url: https://creativecommons.org/ Attribution 4.0 International: icon: fab fa-creative-commons-by url: https://creativecommons.org/licenses/by/4.0/ Fork Me on GitHub: icon: fab fa-github url: https://github.com/HappyhappyChan 代码高亮_config.icarus.yml 如果你已在Hexo中启用了代码高亮功能，你可以通过article中的highlight设置来自定义代码块。 请从highlight.js/src/styles下列出的所有主题中 选择一个主题。 然后，复制文件名(不带.css后缀)到theme设置项中。 如要隐藏复制代码按钮，将clipboard设置为false。 如果你希望折叠或展开所有代码块，将fold设置为&quot;folded&quot;或&quot;unfolded&quot;。 你也可以将fold设置为空来禁止代码块折叠。 123456789article: highlight: # 代码高亮主题 # https://github.com/highlightjs/highlight.js/tree/master/src/styles theme: atom-one-light # 显示复制代码按钮 clipboard: true # 代码块的默认折叠状态。可以是&quot;&quot;, &quot;folded&quot;, &quot;unfolded&quot; fold: unfolded Coverxx.md 12345678910title: 'Hexo Theme Modification: Icarus'date: 2022-04-13 10:31:14tags:- Hexo- Websitecategories: - Coding- Webcover: /img/covers/Hexo-Theme-Modification-Icarus.pngthumbnail: /img/covers/Hexo-Theme-Modification-Icarus.png Reading Time12article: readtime: true Updated Time_config.icarus.yml 1234title: Icarus快速上手updated: 2020-04-01 00:00:00---Post content... 然后，将主题配置文件的article部分的update_time设置为true： 12article: update_time: true 你也可以将update_time设置为false来隐藏所有文章的更新时间，或设置为auto而在文章的更新时间 与发布时间相同时隐藏更新时间。 License_config.icarus.yml 1234567article: # 文章许可协议 licenses: Creative Commons: icon: fab fa-creative-commons url: 'https://creativecommons.org/' 'CC BY-NC-SA 4.0': 'https://creativecommons.org/licenses/by-nc-sa/4.0/' _config.yml 123456789title: HappyhappyChan's-Blogsubtitle: ''description: ''keywords: nullauthor: Happyhappy Chanlanguage: entimezone: ''url: https://happyhappychan.github.io/permalink: ':year/:month/:day/:title/' Sidebar_config.icarus.yml 12345sidebar: left: sticky: false right: sticky: true Priority除了在_config.icarus.yml的默认主题配置文件外，Icarus也会从如下位置获取替代配置： 位于_config.yml的站点配置文件 位于_config.post.yml和_config.page.yml的布局配置文件 文章/页面的front-matter (已弃用) 位于themes/icarus/_config.yml的旧主题配置文件 (已弃用) 位于themes/icarus/_config.post.yml和themes/icarus/_config.page.yml的旧布局配置文件 总而言之，配置源的作用范围和优先级如下： 对于某个文章或页面 文章/页面的front-matter覆盖所有下面的配置源。 布局配置文件覆盖所有下面的配置源。 站点配置文件中的theme_config选项覆盖所有下面的配置源。 主题配置文件覆盖所有下面的配置源。 站点配置文件。 对于所有的文章或页面 布局配置文件覆盖所有下面的配置源。 站点配置文件中的theme_config选项覆盖所有下面的配置源。 主题配置文件覆盖所有下面的配置源。 站点配置文件。 对于所有的文章，页面，和索引页 站点配置文件中的theme_config选项覆盖所有下面的配置源。 主题配置文件覆盖所有下面的配置源。 站点配置文件。 Category123categories: - Coding- Web 显示为： Coding Web Icon使用的是fontawesome 5.15版本的图标，如果页面不能正常显示图标，思考 图标版本 图标是否免费 查看图片是否付费 _config.icarus.yml 123456Github: icon: fab fa-github url: https://github.com/HappyhappyChan Email: icon: fas fa-envelope url: mailto:chenlh65@mail2.sysu.edu.cn Mailto邮件点击发送的功能 _config.icarus.yml 123Email: icon: fas fa-envelope url: mailto:chenlh65@mail2.sysu.edu.cn 布局文章页面设为两栏布局在_config.icarus.yml目录下，创建_config.post.yml文件，该文件内容与_config.icarus.yml文件一样，用于单独加载post界面布局。注意，双栏需要将widgets内容的position都设置为同一边。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354widgets: - position: left type: profile author: HappyhappyChan author_title: Keep investigating location: China Mainland avatar: /img/Himawali.png avatar_rounded: True #false gravatar: #chenlh65@mail2.sysu.edu.cn follow_link: https://github.com/HappyhappyChan social_links: Github: icon: fab fa-github url: https://github.com/HappyhappyChan Email: icon: fas fa-envelope # url: https://facebook.com url: mailto:chenlh65@mail2.sysu.edu.cn Twitter: icon: fab fa-twitter # url: https://twitter.com url: / Dribbble: icon: fab fa-dribbble # url: https://dribbble.com url: / RSS: icon: fas fa-rss url: / - position: left type: toc index: true collapsed: true depth: 3 # - # position: left # type: links # links: # Hexo: https://hexo.io # Bulma: https://bulma.io - position: left type: categories - position: left #left type: recent_posts - position: left #left type: archives - position: left #left type: tags 增加两栏布局下文章的宽度12345// layout/layout.jsx &lt;Head site={site} config={config} helper={helper} page={page} /&gt;- &lt;body class={`is-${columnCount}-column`}&gt;+ &lt;body class={`is-3-column`}&gt; &lt;Navbar config={config} helper={helper} page={page} /&gt; 12345//layout/layout.jsx 'is-12': columnCount === 1,- 'is-8-tablet is-8-desktop is-8-widescreen': columnCount === 2,+ 'is-8-tablet is-8-desktop is-9-widescreen': columnCount === 2, 'is-8-tablet is-8-desktop is-6-widescreen': columnCount === 3 123456789// layout/common/widgets.jsxfunction getColumnSizeClass(columnCount) { switch (columnCount) { case 2:- return 'is-4-tablet is-4-desktop is-4-widescreen';+ return 'is-4-tablet is-4-desktop is-3-widescreen'; case 3: return 'is-4-tablet is-4-desktop is-3-widescreen'; } 优化不同屏幕大小下的宽度123456789101112131415161718# include/style/responsive.styl +widescreen()+ .is-3-column .container+ max-width: $widescreen - $gap+ width: $widescreen - $gap+ .is-1-column .container, .is-2-column .container max-width: $desktop - 2 * $gap width: $desktop - 2 * $gap +fullhd()+ .is-3-column .container+ max-width: $fullhd - 2 * $gap+ width: $fullhd - 2 * $gap+ .is-2-column .container max-width: $widescreen - 2 * $gap width: $widescreen - 2 * $gap 优化标题布局这里将标题移动到正文上方，增加了更新时间，以及相对应的图标。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//layout/common/article.jsx&lt;div class=&quot;card&quot;&gt; {/* Thumbnail */} {cover ? &lt;div class=&quot;card-image&quot;&gt; {index ? &lt;a href={url_for(page.link || page.path)} class=&quot;image is-7by3&quot;&gt; &lt;img class=&quot;fill&quot; src={cover} alt={page.title || cover} /&gt; &lt;/a&gt; : &lt;span class=&quot;image is-7by3&quot;&gt; &lt;img class=&quot;fill&quot; src={cover} alt={page.title || cover} /&gt; &lt;/span&gt;} &lt;/div&gt; : null} &lt;article class={`card-content article${'direction' in page ? ' ' + page.direction : ''}`} role=&quot;article&quot;&gt; {/* Metadata */} {/* Title */} &lt;h1 className=&quot;title is-size-3 is-size-4-mobile has-text-weight-normal&quot;&gt; {index ? &lt;a class=&quot;link-muted&quot; href={url_for(page.link || page.path)}&gt;{page.title}&lt;/a&gt; : page.title} &lt;/h1&gt; {page.layout !== 'page' ? &lt;div class=&quot;article-meta is-size-7 is-uppercase level is-mobile&quot;&gt; &lt;div class=&quot;level-left&quot;&gt; {/* Creation Date */} {/* {page.date &amp;&amp; &lt;span class=&quot;level-item&quot; dangerouslySetInnerHTML={{ __html: _p('article.created_at', `&lt;time dateTime=&quot;${date_xml(page.date)}&quot; title=&quot;${new Date(page.date).toLocaleString()}&quot;&gt;${date(page.date)}&lt;/time&gt;`) }}&gt;&lt;/span&gt;} */} {page.date &amp;&amp; &lt;span class=&quot;level-item&quot;&gt; &lt;i className=&quot;far fa-calendar-alt&quot;&gt;&amp;nbsp;&lt;/i&gt; &lt;time dateTime={date_xml(page.date)} title={date_xml(page.date)}&gt;{date(page.date)}&lt;/time&gt; &lt;/span&gt;} {/* Last Update Date */} {/* {shouldShowUpdated &amp;&amp; &lt;span class=&quot;level-item&quot; dangerouslySetInnerHTML={{ __html: _p('article.updated_at', `&lt;time dateTime=&quot;${date_xml(page.updated)}&quot; title=&quot;${new Date(page.updated).toLocaleString()}&quot;&gt;${date(page.updated)}&lt;/time&gt;`) }}&gt;&lt;/span&gt;} */} {shouldShowUpdated &amp;&amp; &lt;span class=&quot;level-item is-hidden-mobile&quot;&gt; {/* &lt;i class=&quot;far fa-calendar-edit&quot;&gt;&lt;/i&gt; 因为是专业版 所以不能免费用……*/ } &lt;i class=&quot;far fa-calendar-check&quot;&gt;&amp;nbsp;&lt;/i&gt; &lt;time dateTime={date_xml(page.updated)} title={date_xml(page.updated)}&gt;{date(page.updated)}&lt;/time&gt; &lt;/span&gt;} {/* author */} {page.author ? &lt;span class=&quot;level-item&quot;&gt; {page.author} &lt;/span&gt; : null} {/* Categories */} {page.categories &amp;&amp; page.categories.length ? &lt;span class=&quot;level-item&quot;&gt; &lt;i className=&quot;far fa-folder-open&quot;&gt;&amp;nbsp;&lt;/i&gt; {(() =&gt; { const categories = []; page.categories.forEach((category, i) =&gt; { categories.push(&lt;a class=&quot;link-muted&quot; href={url_for(category.path)}&gt;{category.name}&lt;/a&gt;); if (i &lt; page.categories.length - 1) { categories.push(&lt;span&gt;&amp;nbsp;/&amp;nbsp;&lt;/span&gt;); } }); return categories; })()} &lt;/span&gt; : null} {/* Read time */} {article &amp;&amp; article.readtime &amp;&amp; article.readtime === true ? &lt;span class=&quot;level-item&quot;&gt; &lt;i class=&quot;far fa-clock&quot;&gt;&amp;nbsp;&lt;/i&gt; {(() =&gt; { const words = getWordCount(page._content); const time = moment.duration((words / 150.0) * 60, 'seconds'); return `${_p('article.read_time', time.locale(index ? indexLaunguage : language).humanize())} (${_p('article.word_count', words)})`; })()} &lt;/span&gt; : null} {/* Visitor counter */} {!index &amp;&amp; plugins &amp;&amp; plugins.busuanzi === true ? &lt;span class=&quot;level-item&quot; id=&quot;busuanzi_container_page_pv&quot; dangerouslySetInnerHTML={{ __html: _p('plugin.visit_count', '&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;0&lt;/span&gt;') }}&gt;&lt;/span&gt; : null} &lt;/div&gt; &lt;/div&gt; : null} {/* Title */} {/* {page.title !== '' ? &lt;h1 class=&quot;title is-3 is-size-4-mobile&quot;&gt; {index ? &lt;a class=&quot;link-muted&quot; href={url_for(page.link || page.path)}&gt;{page.title}&lt;/a&gt; : page.title} &lt;/h1&gt; : null} */} {/* Content/Excerpt */} &lt;div class=&quot;content&quot; dangerouslySetInnerHTML={{ __html: index &amp;&amp; page.excerpt ? page.excerpt : page.content }}&gt;&lt;/div&gt; {/* Licensing block */} 标题下方的发布时间与更新时间均改为直接使用日期。 123456//source/js/main.js- if (typeof moment === 'function') {- $('.article-meta time').each(function() {- $(this).text(moment($(this).attr('datetime')).fromNow());- });- } 优化文章结尾布局在文章结尾增加一个hr以调整间距。另外设置在预览时也显示标签（tags），并将Read More按钮置于右侧且添加图标 1234567891011121314151617181920212223//layout/common/article.jsx{/* Licensing block */} {!index &amp;&amp; article &amp;&amp; article.licenses &amp;&amp; Object.keys(article.licenses) ? &lt;ArticleLicensing.Cacheable page={page} config={config} helper={helper} /&gt; : null} &lt;hr style=&quot;height:1px;margin:1rem 0&quot;/&gt; &lt;div className=&quot;level is-mobile is-flex&quot;&gt; {/* Tags */} {/* {!index &amp;&amp; page.tags &amp;&amp; page.tags.length ? &lt;div class=&quot;article-tags is-size-7 mb-4&quot;&gt; &lt;span class=&quot;mr-2&quot;&gt;#&lt;/span&gt; {page.tags.map(tag =&gt; { return &lt;a class=&quot;link-muted mr-2&quot; rel=&quot;tag&quot; href={url_for(tag.path)}&gt;{tag.name}&lt;/a&gt;; */} {page.tags &amp;&amp; page.tags.length ? &lt;div class=&quot;article-tags is-size-7 is-uppercase&quot;&gt; &lt;i class=&quot;fas fa-tags has-text-grey&quot;&gt;&lt;/i&gt;&amp;nbsp; {page.tags.map((tag, index) =&gt; { return &lt;a class=&quot;link-muted&quot; rel=&quot;tag&quot; href={url_for(tag.path)}&gt;{tag.name}{index !== page.tags.length-1? ', ':''}&lt;/a&gt;; })} &lt;/div&gt; : null} {/* &quot;Read more&quot; button */} {/* {index &amp;&amp; page.excerpt ? &lt;a class=&quot;article-more button is-small is-size-7&quot; href={`${url_for(page.link || page.path)}#more`}&gt;{__('article.more')}&lt;/a&gt; : null} */} {index &amp;&amp; page.excerpt ? &lt;a class=&quot;article-more button is-small is-size-7&quot; href={`${url_for(page.link || page.path)}#more`}&gt;&lt;i class=&quot;fas fa-book-reader has-text-grey&quot;&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;{__('article.more')}&lt;/a&gt; : null} &lt;/div&gt; {/* Share button */} 目录粘性定位12# _config.ymltoc: true #为了增加目录 1234//source/js/main.jsif ($toc.length &gt; 0) {+ $toc.addClass('column-left is-sticky'); const $mask = $('&lt;div&gt;'); 1234//include/style/widget.styl+#toc+ max-height: calc(100vh - 22px)+ overflow-y: scroll 功能夜间模式复制下面的代码，然后在./themes/icarus/source/css/目录下创建night.styl文件并粘贴 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378dark-primary-color = rgb(55, 61, 72)dark-primary-color-hover = rgb(67, 74, 86)dark-primary-color-active = rgb(44, 49, 58)dark-font-color = #c0c0c0#universe display: none.navbar-logo,.footer-logo .logo-img-dark display: nonebody.night background: #0e1225.night // code highlight (https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css) // navigation bar, cards .content code color: rgb(203,186,125) // night icon changed to fas fa-sun #night-nav #night-icon:before content: '\\f185' .navbar-menu background-color: inherit .navbar-main .navbar-menu .navbar-item &amp;:hover, &amp;:focus color: #ffffff background-color: dark-primary-color .navbar, .card background-color: rgba(40, 44, 52, 0.5) backdrop-filter: none -webkit-backdrop-filter: none .card &amp;:hover background-color: rgba(40, 44, 52, 0.8) .footer background-color: rgba(40, 44, 52, 0.5) backdrop-filter: none -webkit-backdrop-filter: none &amp;:before background-color: rgba(40, 44, 52, 0.5) // input .input, .textarea background-color: dark-primary-color-hover border-color: dark-primary-color // message .message.message-immersive background-color: #c2c2c2 .message-body color: #222222 .message.message-immersive.is-info background-color: #bdc3c8 .message-body color: #004779 .message.message-immersive.is-warning background-color: #cbc8ba .message-body color: #5b4b00 .message.message-immersive.is-danger background-color: #c6babe .message-body color: #79000f .message.message-immersive.is-success background-color: #bfc7c0 .message-body color: #1e4d1c .message.message-immersive.is-primary background-color: #bdc0c9 .message-body color: #003790 // button .button.is-primary, .button.is-light, .button.is-small background-color: dark-primary-color color: dark-font-color &amp;:hover, &amp;.is-hovered color: #ffffff background-color: dark-primary-color-hover &amp;:active, &amp;.is-active color: #ffffff background-color: dark-primary-color-active .button.is-white, .button.is-transparent background-color: transparent &amp;:hover background-color: dark-primary-color !important .pagination .pagination-next, .pagination .pagination-previous .pagination-link:not(.is-current) color: dark-font-color // button .button.is-primary, .button.is-light, .button.is-small background-color: dark-primary-color color: dark-font-color &amp;:hover, &amp;.is-hovered color: #ffffff background-color: dark-primary-color-hover &amp;:active, &amp;.is-active color: #ffffff background-color: dark-primary-color-active .button.is-white, .button.is-transparent background-color: transparent &amp;:hover background-color: dark-primary-color !important .pagination .pagination-next, .pagination .pagination-previous .pagination-link:not(.is-current) color: dark-font-color background-color: dark-primary-color a color: dark-font-color .pagination-link.is-current background-color: dark-primary-color-hover border-color: dark-primary-color-hover // comment .v .vwrap, .v .vwrap .vheader .vinput border-color: dark-primary-color .v .vwrap .vheader .vinput:focus border-color: dark-primary-color-hover .v .vbtn color: dark-font-color background-color: dark-primary-color border-color: dark-primary-color &amp;:hover background-color: dark-primary-color-hover &amp;:active background-color: dark-primary-color-active .v .vlist .vcard .vhead .vsys background-color: dark-primary-color .v a:hover, .v .vlist .vcard .vh .vmeta .vat color: #ffffff .v .vlist .vcard .vcontent.expand:before background: -webkit-gradient(linear, left top, left bottom, from(rgba(37, 41, 54, 0)), to(rgba(37, 41, 54, 1))) background: linear-gradient(180deg, rgba(37, 41, 54, 0), rgba(37, 41, 54, 1)) .v .vlist .vcard .vcontent.expand:after background: rgba(37, 41, 54, 1) .v .vlist .vcard .vh, .v .vlist .vcard .vquote border-color: dark-primary-color-hover // font color body, strong, time, .title, .footer, .card, .content h1, .content h2, .content h3, .content h4, .content h5, .content h6, .navbar-item, .navbar-item.is-active, .navbar-link, .menu-list a, .menu-label, .level-item, .input, .textarea, .button.is-white, .button.is-transparent, .article-licensing, .v * color: dark-font-color .media-content, .has-text-grey, .link-muted color: dark-font-color !important a color: rgb(82, 153, 224) &amp;:hover color: #ffffff // quote .content blockquote, .article-licensing background-color: dark-primary-color border-color: dark-primary-color-hover .post-copyright background-color: dark-primary-color border-color: dark-primary-color-hover // table .content table thead td, .content table thead th color: dark-font-color .content table td, .content table th border-color: dark-primary-color-hover // break line hr background-color: dark-primary-color-hover // tags and menus article.article, article.media .title:hover a // override anotherr !important color: dark-font-color !important .tag:not(body) color: dark-font-color background-color: dark-primary-color .tag.is-grey background-color: dark-primary-color-hover .menu-list a:hover background-color: dark-primary-color .menu-list a.is-active background-color: dark-primary-color-hover .menu-list li ul border-color: dark-primary-color // time line .timeline .media:last-child:after background-color: rgb(37, 41, 54) .timeline border-color: dark-primary-color-hover .timeline .media:before background-color: dark-primary-color-hover // search box .searchbox .searchbox-container, .searchbox-header, .searchbox-header .searchbox-input, .searchbox-header .searchbox-close, .searchbox-body, .searchbox-result-section, .searchbox-result-item color: dark-font-color background-color: dark-primary-color border-color: dark-primary-color-hover .searchbox-container .searchbox-result-section .searchbox-result-item:hover, .searchbox-container .searchbox-result-section .searchbox-result-item.active, .searchbox-container .searchbox-header .searchbox-close:hover color: #ffffff background-color: dark-primary-color-hover // selection ::selection color: #ffffff background-color: rgba(52, 109, 167, 0.8) ::-moz-selection color: #ffffff background-color: rgba(52, 109, 167, 0.8) input:-webkit-autofill -webkit-text-fill-color: dark-font-color !important box-shadow: 0 0 0px 1000px dark-primary-color inset .hljs { display: block; overflow-x: auto; padding: 0.5em; color: #abb2bf; background: #282c34 } .hljs-comment, .hljs-quote { color: #5c6370; font-style: italic } .hljs-doctag, .hljs-keyword, .hljs-formula { color: #c678dd } .hljs-section, .hljs-name, .hljs-selector-tag, .hljs-deletion, .hljs-subst { color: #e06c75 } .hljs-literal { color: #56b6c2 } .hljs-string, .hljs-regexp, .hljs-addition, .hljs-attribute, .hljs-meta-string { color: #98c379 } .hljs-built_in, .hljs-class .hljs-title { color: #e6c07b } .hljs-attr, .hljs-variable, .hljs-template-variable, .hljs-type, .hljs-selector-class, .hljs-selector-attr, .hljs-selector-pseudo, .hljs-number { color: #d19a66 } .hljs-symbol, .hljs-bullet, .hljs-link, .hljs-meta, .hljs-selector-id, .hljs-title { color: #61aeee } .hljs-emphasis { font-style: italic } .hljs-strong { font-weight: bold } .hljs-link { text-decoration: underline } 接下来需要修改一下样式文件。 source/css/default.styl 12 @import 'style'+ @import 'night' 然后在./themes/icarus/source/js下创建night.js文件，其内容如下： 1234567891011121314151617181920212223242526272829303132333435363738(function () { /** * Icarus 夜间模式 by iMaeGoo * https://www.imaegoo.com/ */ var isNight = localStorage.getItem('night'); var nightNav; function applyNight(value) { if (value.toString() === 'true') { document.body.classList.remove('light'); document.body.classList.add('night'); } else { document.body.classList.remove('night'); document.body.classList.add('light'); } } function findNightNav() { nightNav = document.getElementById('night-nav'); if (!nightNav) { setTimeout(findNightNav, 100); } else { nightNav.addEventListener('click', switchNight); } } function switchNight() { isNight = isNight ? isNight.toString() !== 'true' : true; applyNight(isNight); localStorage.setItem('night', isNight); } findNightNav(); isNight &amp;&amp; applyNight(isNight);}()); 最后，还要修改一下下面两个文件。 layout/common/scripts.jsx 123 &lt;script src={url_for('/js/main.js')} defer&gt;&lt;/script&gt;+ &lt;script src={url_for('/js/night.js')} defer={true}&gt;&lt;/script&gt; &lt;/Fragment&gt;; layout/commom/navbar.jsx 12345 &lt;div class=&quot;navbar-end&quot;&gt;+ &lt;a class=&quot;navbar-item night&quot; id=&quot;night-nav&quot; title=&quot;Night Mode&quot; href=&quot;javascript:;&quot;&gt;+ &lt;i class=&quot;fas fa-moon&quot; id=&quot;night-icon&quot;&gt;&lt;/i&gt;+ &lt;/a&gt; {Object.keys(links).length ? &lt;Fragment&gt; Page View_config.icarus.yaml 12345678plugins: animejs: true back_to_top: true baidu_analytics: tracking_id: bing_webmaster: tracking_id: busuanzi: True #false 这个是用来计数的 layout/common/article.jsx 1234{/* Visitor counter */} {!index &amp;&amp; plugins &amp;&amp; plugins.busuanzi === true ? &lt;span class=&quot;level-item&quot; id=&quot;busuanzi_container_page_pv&quot; dangerouslySetInnerHTML={{ __html: _p('plugin.visit_count', '&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;0&lt;/span&gt;') }}&gt;&lt;/span&gt; : null} ReferenceIcarus用户指南 - 主题配置 Hexo自主文档 Icon-fontawesome FontAwesome 字体图标库 Icarus主题的一些常用配置 Hexo主题Icarus的自定义 icarus个性化配置 阿里矢量图 失踪人口回归系列之在VPS上搭建HEXO的GIT部署环境 在Hexo博客中发布文章 Epilogue耗时1.5天终于搞完啦，总之今后也要积极探索哟~ Going out into the world and investigating, turning the “unknown” into the “known”.","link":"/2022/04/13/Hexo-Theme-Modification-Icarus/"},{"title":"学习算法和刷题的框架思维","text":"Preface这个系列都是GitHub上fucking-algorithm这个项目的学习笔记。 数据结构的存储数据结构的存储方式只有2种：数组（顺序存储）和链表（链式存储）。 队列、栈这两种数据结构可以用链表也可以用数组实现： 用数组，要处理扩容、缩容 用链表，需要更多的内存空间存储节点 图 邻接表，链表 邻接矩阵，二维数组 判断连通性迅速 矩阵运算 散列表 通过散列函数把键映射到一个大数组里 解决散列冲突 拉链法：用到链表特性、操作简单、额外存储空间指针 线性探查法：数组特性、连续寻址、不需要指针存储 树 用数组实现就是堆 堆其实就是完全二叉树 用数组存储不需要指针结点 用链表实现 不一定是完全二叉树 常见链表树：二叉搜索树、AVL树、红黑树、区间树、B树 数组和链表的比较 数组 紧凑连续存储、随机访问、索引快、省空间 扩容麻烦，时间复杂度O(N) 删除插入麻烦，时间复杂度O(N) 链表 元素不连续，不存在扩容问题，O(1) 删除、插入时间复杂度O(1) 无法随机访问、消耗更多存储空间 数据结构的基本操作概况来说， 遍历+访问，具体地说，增删改查 实现形式2种：线性和非线性 线性：for / while 迭代 非线性：递归 数组遍历框架线性迭代结构 12345void traverse(int[] arr){ for(int i = 0; i &lt; arr.length; i++){ //迭代访问 arr[i] }} 链表遍历框架单链表基本的单链表结点 1234class ListNode{ int val; ListNode next;} 单链表迭代遍历 12345void traverse(ListNode head){ for(ListNode p = head; p != null; p = p.next){ //迭代访问 p.val }} 单链表递归遍历 1234void traverse(ListNOde head){ //递归访问 head.val traverse(head.next)} 二叉树基本的二叉树结点 1234class TreeNode{ int val; TreeNode left, right;} 二叉树遍历，典型的非线性递归遍历 1234void traverse(TreeNode root){ traverse(root.left); traverse(root.right);} N叉树基本的N叉树节点 1234class TreeNode{ int val; TreeNode[] children;} 遍历框架 12345void traverse(TreeNode root){ for(TreeNode: child: root.children){ traverse(child); }} N 叉树的遍历又可以扩展为图的遍历，因为图就是好几个N 叉棵树的结合体。你说图是可能出现环的？这个很 好办，用个布尔数组 visited 做标记就可了，这里就不写代码了 算法刷题指南刷题顺序 数组、链表基本数据结构基本算法，如单链表翻转、前缀、数组、二分搜索等 二叉树、二叉树、二叉树！！培养框架思维，本质上都是树的遍历问题 1234567void traverse(TreeNode root){ //前序位置 traverse(root.left); //中序位置 traverse(root.right); //后序位置} 算法本质本质是穷举，要求：无遗漏、无冗余。 如何穷举？ 如何聪明地穷举？ 常见的算法技巧数组/单链表单链表常考双指针 数组常用的技巧很大一部分还是双指针相关的技巧： 二分搜索 只能用在有序数组上 滑动窗口算法 典型的快慢双指针，快慢指针中间就是滑动的窗口，主要用于解决子串问题 限制：明确知道什么时候扩大窗口，什么时候收缩窗口 回文串 判断是否是回文：双指针从两边向中间检查 找回文子串：从中心向两端扩散 寻找最长回文子串：马拉车算法(Manacher)，不过性价比不高，没必要掌握 前缀和 如果需要频繁计算子数组的和，可以用for循环，但利用前缀和预计算preSUm数组，可以避免循环 差分数组 如果频繁对子数组进行增减，可以用for循环，但用差分数组diff去维护，可以避免循环 二叉树二叉树很重要，几乎是所有高级算法的基础！！ 二叉树的递归解法可以分成两类思路： 遍历一遍二叉树得出答案–》回溯算法 通过分解问题计算出答案–》动态规划 动态规划问题有【最优子结构】和【重叠子问题】两个特性，而且大多都是让求最值的。很多算法虽然不属于动态规划，但也符合分解问题的思维模式。 常用算法：动归、回溯（DFS）、分治、BFS","link":"/2022/04/19/%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%92%8C%E5%88%B7%E9%A2%98%E7%9A%84%E6%A1%86%E6%9E%B6%E6%80%9D%E7%BB%B4/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Website","slug":"Website","link":"/tags/Website/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"Fucking-algorithm","slug":"Fucking-algorithm","link":"/tags/Fucking-algorithm/"}],"categories":[{"name":"Coding","slug":"Coding","link":"/categories/Coding/"},{"name":"Web","slug":"Coding/Web","link":"/categories/Coding/Web/"},{"name":"Algorithm","slug":"Coding/Algorithm","link":"/categories/Coding/Algorithm/"}]}