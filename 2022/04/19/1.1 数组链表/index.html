<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>1.1 数组链表 - HappyhappyChan&#039;s-Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="HappyhappyChan&#039;s-Blog"><meta name="msapplication-TileImage" content="/img/crayon-shinchan-logo.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="HappyhappyChan&#039;s-Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Preface这部分是有关数组和链表的算法，包括：前缀和、差分数组、双指针、滑动窗口、二分搜索、递归、田忌赛马等。"><meta property="og:type" content="blog"><meta property="og:title" content="1.1 数组链表"><meta property="og:url" content="https://happyhappychan.github.io/2022/04/19/1.1%20%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/"><meta property="og:site_name" content="HappyhappyChan&#039;s-Blog"><meta property="og:description" content="Preface这部分是有关数组和链表的算法，包括：前缀和、差分数组、双指针、滑动窗口、二分搜索、递归、田忌赛马等。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://happyhappychan.github.io/img/covers/fucking-algorithm.png"><meta property="article:published_time" content="2022-04-19T07:34:58.166Z"><meta property="article:modified_time" content="2022-04-19T07:44:32.152Z"><meta property="article:author" content="Happyhappy Chan"><meta property="article:tag" content="LeetCode"><meta property="article:tag" content="Fucking-algorithm"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/covers/fucking-algorithm.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://happyhappychan.github.io/2022/04/19/1.1%20%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/"},"headline":"1.1 数组链表","image":["https://happyhappychan.github.io/img/covers/fucking-algorithm.png"],"datePublished":"2022-04-19T07:34:58.166Z","dateModified":"2022-04-19T07:44:32.152Z","author":{"@type":"Person","name":"Happyhappy Chan"},"publisher":{"@type":"Organization","name":"HappyhappyChan's-Blog","logo":{"@type":"ImageObject","url":"https://happyhappychan.github.io/img/crayon-shinchan-logo.svg"}},"description":"Preface这部分是有关数组和链表的算法，包括：前缀和、差分数组、双指针、滑动窗口、二分搜索、递归、田忌赛马等。"}</script><link rel="canonical" href="https://happyhappychan.github.io/2022/04/19/1.1%20%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/"><link rel="icon" href="/img/crayon-shinchan-logo.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/crayon-shinchan-logo.svg" alt="HappyhappyChan&#039;s-Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item night" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Fork me on GitHub" href="https://github.com/HappyhappyChan"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/img/covers/fucking-algorithm.png" alt="1.1 数组链表"></span></div><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">1.1 数组链表</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="2022-04-19T07:34:58.166Z" title="2022-04-19T07:34:58.166Z">2022-04-19</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="2022-04-19T07:44:32.152Z" title="2022-04-19T07:44:32.152Z">2022-04-19</time></span><span class="level-item"><i class="far fa-folder-open"> </i><a class="link-muted" href="/categories/Coding/">Coding</a><span> / </span><a class="link-muted" href="/categories/Coding/Algorithm/">Algorithm</a></span><span class="level-item"><i class="far fa-clock"> </i>42 minutes read (About 6362 words)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><div class="content"><h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>这部分是有关数组和链表的算法，包括：前缀和、差分数组、双指针、滑动窗口、二分搜索、递归、田忌赛马等。</p>
<span id="more"></span>

<h2 id="关于基础数据结构"><a href="#关于基础数据结构" class="headerlink" title="关于基础数据结构"></a>关于基础数据结构</h2><p>基础数据结构包括：数组、链表、队列、栈等，因为都比较类似、操作过程不怎么涉及递归，所以都归纳成较为基础的数据结构</p>
<h2 id="数组-x2F-链表"><a href="#数组-x2F-链表" class="headerlink" title="数组&#x2F;链表"></a>数组&#x2F;链表</h2><p>数组、链表代表计算机最基本的两种存储形式：顺序存储、链式存，因此也是最基本的数据结构。</p>
<p>数组链表的主要算法技巧：</p>
<ul>
<li>双指针<ul>
<li>中间向两端扩散的双指针</li>
<li>两端向中间收缩的双指针、快慢指针</li>
</ul>
</li>
<li>前缀和技巧</li>
<li>差分数组技巧</li>
</ul>
<h2 id="前缀和数组"><a href="#前缀和数组" class="headerlink" title="前缀和数组"></a>前缀和数组</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>LeetCode：303、304、560</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>适用于快速、频繁地计算一个索引区间内的元素之和</p>
<h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrefixSum</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] prefix;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrefixSum</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        prefix = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prefix.length; i++)&#123;</span><br><span class="line">            prefix[i] = prefix[i-<span class="number">1</span>]+nums[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 闭区间[i, j] 的累加和*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prefix[j+<span class="number">1</span>]-prefix[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>370， 1109， 1094</p>
<h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><p>频繁对原始数组的某个区间的元素进行增减</p>
<blockquote>
<p>例子</p>
<p>我给你输⼊⼀个数组 nums，然后⼜要求给区间 nums[2..6] 全部加 1，再给 nums[3..9] 全部减 3，再给 nums[0..4] 全部加 2，再给…</p>
<p>问最后 nums 数组的值是什么？</p>
</blockquote>
<h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>构造一个diff差分数组，<code>diff[i]</code> 就是 <code>nums[i]-nums[i-1]</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] diff = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line"><span class="comment">//构造差分数组</span></span><br><span class="line">diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">	diff[i] = nums[i] - nums[i-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用差分数组<code>diff</code>反推出原始数组<code>nums</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[diff.length];</span><br><span class="line"><span class="comment">//根据差分数组构造结果数组</span></span><br><span class="line">res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; diff.length; i++)&#123;</span><br><span class="line">    res[i] = res[i-<span class="number">1</span>] + diff[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想对区间<code>nums[i..j]</code>的元素全部加3，只要让<code>diff[i] += 3</code>， 然后再让<code>diff[j+1] -= 3</code>即可</p>
<p>原理很简单，回想 diff 数组反推 nums 数组的过程，<code>diff[i] += 3</code> 意味着给 <code>nums[i..]</code> 所有的元素都 加了 3，然后 <code>diff[j+1] -= 3</code> ⼜意味着对于 <code>nums[j+1..]</code> 所有元素再减 3，那综合起来，是不是就是对 <code>nums[i..j]</code> 中的所有元素都加 3 了？</p>
<p>只要花费 O(1) 的时间修改 diff 数组，就相当于给 nums 的整个区间做了修改。多次修改 diff，然后通过 diff 数组反推，即可得到 nums 修改后的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Difference</span>&#123;</span><br><span class="line">    <span class="comment">//差分数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] diff;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*输入一个初始数组，区间操作将在这个数组上进行*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Difference</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> nums.length &gt; <span class="number">0</span>;</span><br><span class="line">        diff = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            diff[i] = nums[i] - nums[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*给闭区间[i,j]增加val (val可以为负)*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">        diff[i] += val;</span><br><span class="line">        <span class="keyword">if</span>(j + <span class="number">1</span> &lt; diff.length)&#123;</span><br><span class="line">            diff[j+<span class="number">1</span>] -= val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*返回结果数组*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] result()&#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[diff.length];</span><br><span class="line">        res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; diff.length; i++)&#123;</span><br><span class="line">            res[i] = res[i-<span class="number">1</span>] + diff[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 j+1 &gt;&#x3D; diff.length 时，说明是对 nums[i] 及以后的整个数组都进⾏修改，那么就不需要再给 diff 数组减 val 了。</p>
<h2 id="双指针技巧秒杀链表"><a href="#双指针技巧秒杀链表" class="headerlink" title="双指针技巧秒杀链表"></a>双指针技巧秒杀链表</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>21、23、141、142、876、19、160</p>
<h3 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h3><p>单链表常见算法题：</p>
<ol>
<li>合并两个有序链表</li>
<li>合并k个有序链表</li>
<li>寻找单链表的倒数第k个节点</li>
<li>寻找单链表的中点</li>
<li>判断单链表是否包含环并找出环起点</li>
<li>判断两个单链表是否相交并找出交点</li>
</ol>
<p>上述都用到了双指针技巧</p>
<h3 id="框架-1"><a href="#框架-1" class="headerlink" title="框架"></a>框架</h3><h4 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h4><p>这个算法的逻辑类似于【拉拉链】，l1, l2 类似拉链两侧的锯齿，p就像拉链的拉索，将两个有序链表合并。</p>
<p>链表的算法题中常见的技巧：虚拟头结点，也就是dummy结点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span>&#123;</span><br><span class="line">    <span class="comment">//虚假头结点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>), p = dummy;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> l1, p2 = l2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(p1 != <span class="literal">null</span> &amp;&amp; p2 != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//比较p1 p2两个指针</span></span><br><span class="line">        <span class="comment">//将小的节点接在p指针后面</span></span><br><span class="line">        <span class="keyword">if</span>(p1.val &gt; p2.val)&#123;</span><br><span class="line">            p.next = p2;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p.next = p1;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p1 != <span class="literal">null</span>)&#123;</span><br><span class="line">		p.next = p1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p2 != <span class="literal">null</span>)&#123;</span><br><span class="line">        p.next = p2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="合并k个有序链表"><a href="#合并k个有序链表" class="headerlink" title="合并k个有序链表"></a>合并k个有序链表</h4><p>难点：如何快速得到k个结点中的最小结点，接到结果链表上。</p>
<p>解决：使用优先级队列（二叉堆），把链表结点放入一个最小堆，就可以每次获得k个结点中的最小结点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//虚拟头结点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="comment">//优先级队列，最小堆</span></span><br><span class="line">    PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(</span><br><span class="line">    	lists.length, (a, b) -&gt; (a.val - b.val));</span><br><span class="line">    <span class="comment">//将k个链表的头结点加入最小堆</span></span><br><span class="line">    <span class="keyword">for</span>(ListNode head: lists)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head != <span class="literal">null</span>)</span><br><span class="line">            pq.add(head);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//获取最小结点，接到结果链表中</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">        p.next = node;</span><br><span class="line">        <span class="keyword">if</span>(node.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            pq.add(node.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//p指针不断前进</span></span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度分析：</p>
<p>优先队列pq中的元素个数最多是k， 所以一次 poll 或者 add 的时间复杂度是<code>O(logk)</code></p>
<p>所有链表的节点都会被加入和弹出<code>pq</code>， 所以算法整体的时间复杂度是<code>O(Nlogk)</code>，其中k是链表的条数， N是这些链表的节点总数</p>
<h4 id="单链表的倒数第k个结点"><a href="#单链表的倒数第k个结点" class="headerlink" title="单链表的倒数第k个结点"></a>单链表的倒数第k个结点</h4><blockquote>
<p> 最暴力的方法：【两次遍历】</p>
</blockquote>
<p>先从头遍历得出链表长度，然后再次遍历计算得到第 n-k+1个节点</p>
<blockquote>
<p>双链表解法：【双指针一次遍历】</p>
</blockquote>
<p>先让指针p1指向链表的头结点head，走k步；此时p1只用再走n-k步，就可以走到链表末尾的空指针</p>
<p>然后让指针p2指向链表头结点head</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ListNode <span class="title function_">findFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">//p1 先走k步</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// p1 p2同时走 n-k 步</span></span><br><span class="line">    whle(p1 != <span class="literal">null</span>)&#123;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//p2 现在指向第n-k个结点</span></span><br><span class="line">    <span class="keyword">return</span> p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度分析</p>
</blockquote>
<p>用big O表示法来计算时间复杂度，遍历1次or2次时间复杂度都是O(N)，但是这个算法更有技巧性。</p>
<blockquote>
<p>注意</p>
</blockquote>
<p>不过注意我们使用了虚拟头结点的技巧，也是为了防止出现空指针的情况，比如说链表总共有 5 个节点， 题⽬就让你删除倒数第 5 个节点，也就是第⼀个节点，那按照算法逻辑，应该⾸先找到倒数第 6 个节点。但 第⼀个节点前面已经没有节点了，这就会出错。<br>但有了我们虚拟节点 dummy 的存在，就避免了这个问题，能够对这种情况进行正确的删除。</p>
<h4 id="单链表的中点"><a href="#单链表的中点" class="headerlink" title="单链表的中点"></a>单链表的中点</h4><p>对应LeetCode 876</p>
<blockquote>
<p>暴力</p>
</blockquote>
<p>先遍历链表计算链表长度n，然后再遍历一次得到第n&#x2F;2个结点</p>
<blockquote>
<p>快慢指针</p>
</blockquote>
<p>慢指针走1步，快指针走2步，快指针走到末尾，慢指针就走到了中点.</p>
<p>当链表长度为偶数时，返回的节点是靠后的节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ListNode <span class="title function_">middleNode</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">    <span class="comment">//快慢指针初始化指向head</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断链表是否包含环"><a href="#判断链表是否包含环" class="headerlink" title="判断链表是否包含环"></a>判断链表是否包含环</h4><blockquote>
<p>快慢指针</p>
</blockquote>
<p>slow走1步，fast走2步，如果fast最终遇到空指针，说明没有环，如果fast和slow最终相遇，说明fast超过slow一圈，说明链表中有环。</p>
<blockquote>
<p>题目：141 easy</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">    <span class="comment">//快慢指针初始化指向head</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">    <span class="comment">//快指针走到末尾时停止</span></span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//慢指针走一步，快指针走2步</span></span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="keyword">if</span>(slow == fast)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断环的起点"><a href="#判断环的起点" class="headerlink" title="判断环的起点"></a>判断环的起点</h4><blockquote>
<p>题目：142 Medium</p>
</blockquote>
<blockquote>
<p>解析</p>
</blockquote>
<p>我们假设快慢指针相遇时，慢指针 slow 走了 k 步，那么快指针 fast 一定走了 2k 步。</p>
<p>这多走的k步其实就是在环里面转圈，所以k的值就是环长度的整数倍。</p>
<p>假设相遇点距环的起点距离为m，慢指针走了k步，则环起点距离head有k-m步。所以从相遇点开始走k步就可以转回到相遇点，走k-m步就是走到环起点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">    ListNode fast, slow;</span><br><span class="line">    fast = slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span>(slow = fast)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">//说明没有环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//重新指向头结点</span></span><br><span class="line">    slow = head;</span><br><span class="line">    <span class="comment">//快慢指针同步进行，相交点就是环起点</span></span><br><span class="line">    <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="两个链表是否相交"><a href="#两个链表是否相交" class="headerlink" title="两个链表是否相交"></a>两个链表是否相交</h4><blockquote>
<p>题目：160</p>
</blockquote>
<p>暴力法：</p>
<p>用HastSet记录一个链表的所有结点，然后和另一条链表对比，这需要额外空间</p>
<p>双指针：</p>
<p>让p1遍历完A链表，之后开始遍历B链表。</p>
<p>让p2遍历完B链表后开始遍历A链表，这样逻辑上连接在一起。</p>
<p>这样拼接可以使p1 p2同时进入公共部分，达到交点。</p>
<p>如果没有交点，返回null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode heada, ListNode headb)</span>&#123;</span><br><span class="line">    <span class="comment">//p1 指向 A链表头结点，p2指向B链表头结点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> head1, p2 = headb;</span><br><span class="line">    <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line">        <span class="comment">//p1 走一步，如果走到A链表末尾，转到B链表</span></span><br><span class="line">        <span class="keyword">if</span>(p1 == <span class="literal">null</span>)&#123;</span><br><span class="line">            p1 = headb;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//p2 走1步，如果走到B链表末尾，转到A链表</span></span><br><span class="line">        <span class="keyword">if</span>(p2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            p2 = heada;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="keyword">return</span> p1;</span><br><span class="line">    <span class="comment">//上面也可以变成</span></span><br><span class="line">    <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line">            p1 = p1 == <span class="literal">null</span> ? headB : p1.next;</span><br><span class="line">            p2 = p2 == <span class="literal">null</span> ? headA : p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：判断条件一定是p1 or p2 &#x3D;&#x3D; null? 而不是p1.next or p2.next &#x3D;&#x3D; null吗，否则会出现不相交，然后一直在while里面死循环的情况。</p>
<blockquote>
<p>复杂度</p>
</blockquote>
<p>空间复杂度O(1)，时间复杂度O(N)</p>
<p>转换成环的问题：将两条链表首尾相连，转换成求环起点问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode heada, ListNode headb)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lena</span> <span class="operator">=</span> <span class="number">0</span>, lenb = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//计算两条链表长度</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> heada; p1 != <span class="literal">null</span>; p1 = p1.next)&#123;</span><br><span class="line">        lena++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> headb; p2 != <span class="literal">null</span>; p2 = p2.next)&#123;</span><br><span class="line">        lenb++;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//让p1 和 p2达到尾部距离相同</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> heada, p2 = headb;</span><br><span class="line">    <span class="keyword">if</span>(lena &gt; lenb)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lena - lenb; i++)&#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lenb - lena; i++)&#123;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//看两个指针是否会相同,p1==p2时有两种情况</span></span><br><span class="line">    <span class="comment">// 1 两条链表不相交，同时走到尾部空指针</span></span><br><span class="line">    <span class="comment">// 2 要是两条链表相交，走到两个链表的相交点</span></span><br><span class="line">    <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>虽然代码多一些，时间复杂度还是O(N)</p>
<h2 id="双指针技巧秒杀数组"><a href="#双指针技巧秒杀数组" class="headerlink" title="双指针技巧秒杀数组"></a>双指针技巧秒杀数组</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>26、83、27、283、167、344、5</p>
<p>在处理数组和链表的时候，双指针技巧经常使用，主要技巧分为两类：左右指针和快慢指针。</p>
<p>左右指针：两个指针相向而行或相背而行</p>
<p>快慢指针：两个指针同向而行，一快一慢</p>
<p>对单链表来说，大部分技巧属于快慢指针。</p>
<p>在数组中没有真正意义上的指针，所以可以把索引当做数组中的指针，这样也可以在数组中施展双指针。</p>
<h3 id="快慢指针技巧"><a href="#快慢指针技巧" class="headerlink" title="快慢指针技巧"></a>快慢指针技巧</h3><p>场景：数组问题中比较常见且难度不高的快慢指针技巧，是让你原地修改数组。</p>
<p>题目：</p>
<p>26 删除有序数组中的重复项</p>
<p>83 删除排序链表中的重复元素</p>
<p>27 移除元素</p>
<p>注意！不要忘了先判断最简单的情况！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>; </span><br></pre></td></tr></table></figure>

<h3 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//滑动窗口算法框架</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">slidingWindow</span><span class="params">(string s, string t)</span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c: t) need[c]++;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.size())&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s[right];</span><br><span class="line">        <span class="comment">//右移增大窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">//进行窗口内数据的一系列更新</span></span><br><span class="line">        <span class="keyword">while</span>(window needs shrink)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s[left];</span><br><span class="line">            <span class="comment">//左移缩小窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">//进行窗口内数据的一系列更新</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="左右指针的常用算法"><a href="#左右指针的常用算法" class="headerlink" title="左右指针的常用算法"></a>左右指针的常用算法</h3><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>前提条件：有序！</p>
<p>由于其他地方有详细探讨二分搜索代码的细节问题，这里只写最简单的二分算法，旨在突出他双指针的特性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="comment">//一左一右两个指针相向而行</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (right + left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">            right = mid-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h4><p>题目：167 两数之和</p>
<h4 id="反转数组"><a href="#反转数组" class="headerlink" title="反转数组"></a>反转数组</h4><p>题目：344 反转字符串</p>
<p>5 最长回文子串</p>
<p><strong>判断是否是回文串：从两边向中间</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span>&#123;</span><br><span class="line">	<span class="comment">//一左一右两个指针相向而行</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = s.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(left) != s.charAt(right))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>寻找回文串，从中间向两边</strong></p>
<p>回文串的长度可能是奇数也可能是偶数，所以解决问题的核心是从中心向两端扩散。</p>
<p>如果回文串长度是奇数，则有一个中心字符；如果是偶数，则有2个中心字符，因此可以先实现这样一个函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在S中寻找以s[l] s[r]为中心的最长回文串</span></span><br><span class="line">String <span class="title function_">palindrome</span><span class="params">(String s, <span class="type">int</span> l, <span class="type">int</span> r)</span>&#123;</span><br><span class="line">    <span class="comment">//防止索引越界</span></span><br><span class="line">    <span class="keyword">while</span>(l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r))&#123;</span><br><span class="line">        l--;</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回s[l] 和 s[r]为中心的最长回文串</span></span><br><span class="line">    <span class="keyword">return</span> s.substring(l+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p>76 最小覆盖子串 hard</p>
<p>567 字符串排列 medium</p>
<p>438 Find All Anagrams in a String 找到字符串中所有字母异位词 medium</p>
<p>3 Longest Substring Without Repeating Character 最长无重复子串 medium ：如果说只有字母那可以用数组，但是没说就可能包含特殊符号，还是要用hashmap</p>
<h3 id="技巧顺口溜"><a href="#技巧顺口溜" class="headerlink" title="技巧顺口溜"></a>技巧顺口溜</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">链表子串数组题，使用双针别犹豫</span><br><span class="line"></span><br><span class="line">快慢指针最神奇，链表操作无压力</span><br><span class="line">归并排序找中点，链表成环搞判定</span><br><span class="line"></span><br><span class="line">左右指针最常见，左右两端相向行</span><br><span class="line">反转数组要靠他，二分搜索是弟弟</span><br><span class="line"></span><br><span class="line">滑动窗口要背下，子串问题全靠他</span><br></pre></td></tr></table></figure>

<h3 id="框架-2"><a href="#框架-2" class="headerlink" title="框架"></a>框架</h3><p>算法思路：维护一个窗口，不断滑动</p>
<p>时间复杂度：O(N)</p>
<p>算法逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(right &lt; s.size())&#123;</span><br><span class="line">    <span class="comment">// 增大窗口</span></span><br><span class="line">	window.add(s[right]);</span><br><span class="line">    right++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(window needs shrink)&#123;</span><br><span class="line">        <span class="comment">//缩小窗口</span></span><br><span class="line">        window.remove(s[left]);</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//滑动窗口算法框架</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">slidingWindow</span><span class="params">(String s, String t)</span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c: t) need[c]++;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.size())&#123;</span><br><span class="line">        <span class="comment">//c是将移入窗口的字符</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s[right];</span><br><span class="line">        <span class="comment">//增大窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">//进行窗口内数据的一系列更新</span></span><br><span class="line">        <span class="comment">// ... 更新窗口数据【扩大窗口】</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment">//debug 输出位置</span></span><br><span class="line">        printf(<span class="string">&quot;window:[%d, %d]\n&quot;</span>, left, right);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断左窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span>(window needs shrink)&#123;</span><br><span class="line">            <span class="comment">//d是将移出窗口的字符</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s[left];</span><br><span class="line">            <span class="comment">//缩小窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">//进行窗口内数据的一系列更新</span></span><br><span class="line">            <span class="comment">//... 更新窗口数据【缩小窗口】</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是用cpp实现的，下面解释一下：</p>
<p>unorder_map 就是哈希表（字典），相当于 HashMap， 他的一个方法count(key)相当于java的containsKey(key) 可以判断key是否存在</p>
<p>可以使用方括号访问键对应的值<code>map[key]</code>。需要注意的是，可以这个<code>key</code>不存在，cpp会自动创建这个<code>key</code>，然后把<code>map[key]</code>的值赋值0。所以代码中多次出现的<code>map[key]++</code>相当于Java的<code>map.put[key, map.getOrDefault(key,0)+1]</code></p>
<p>另外，Java中的integer和String这种包装类不能直接用<code>==</code>进行相等判断，而应该使用类的<code>equals</code>方法。</p>
<h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h2><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><p>704 Binary Search Easy</p>
<p>34 Find First and Last Position of Element in Sorted Array</p>
<h3 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h3><p>【前提】有序数组</p>
<p>二分查找思路简单，细节是魔鬼。很多人喜欢拿整型溢出的bug说事，但二分查找真正的坑在于到底要给<code>mid</code>加一还是减一，<code>while</code>里到底用&lt;&#x3D;还是&lt;。</p>
<ul>
<li>寻找一个数</li>
<li>寻找左边界</li>
<li>寻找右边界</li>
</ul>
<h3 id="技巧顺口溜-1"><a href="#技巧顺口溜-1" class="headerlink" title="技巧顺口溜"></a>技巧顺口溜</h3><p>管他左侧还是右侧，搜索区间定乾坤</p>
<p>搜索一个元素时，搜索区间两端闭，while条件带等号，否则就要出问号。遇到<code>if</code>相等就返回，其他事情别操心。<code>mid</code>必须加减1，因为区间两端闭，while结束返-1。</p>
<p>搜索左右边界时，搜索区间要阐明，左闭右开最常见，while要用小于号，if相等别返回，利用<code>mid</code>锁边界，<code>mid</code>加减看开闭。while结束不算完，因为你还没返回，索引可能出边界，要用if来check check。</p>
<h3 id="二分查找框架"><a href="#二分查找框架" class="headerlink" title="二分查找框架"></a>二分查找框架</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = ...;</span><br><span class="line">    <span class="keyword">while</span>(...)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析二分查找的一个技巧是：不要出现else，把所有情况用else if写清楚，这样可以清楚地展示所有的细节。</p>
<p>上面代码中…标记的部分，就是可能出现细节问题的地方，但你遇到一个二分查找的代码，首先注意这几个地方。</p>
<p>计算<code>mid</code>的时候要防止溢出，代码中<code>left+(right-left)/2</code>和<code>(left+right)/2</code>结果相同，但是有效防止了left right太大，直接相加导致溢出的情况。</p>
<h3 id="寻找一个数-基本的二分搜索"><a href="#寻找一个数-基本的二分搜索" class="headerlink" title="寻找一个数(基本的二分搜索)"></a>寻找一个数(基本的二分搜索)</h3><p>搜索一个数，如果存在返回其索引，否则返回-1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; <span class="comment">//注意</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>while中循环条件是&lt;&#x3D;而不是&lt;</p>
<p>因为初始化中right的赋值是nums.length - 1, 即最后一个元素的索引，而不是nums.length;</p>
<p>前者相当于两端都闭区间<code>[left, right]</code>，后者相当于左闭右开区间<code>[left, right)</code>，因为索引大小为 <code>nums.length</code>是越界的</p>
<p>这里采用<code>[left, right]</code>两端都闭，这个区间其实就是每次进行搜索的区间</p>
</li>
<li><p>何时停止搜索</p>
<p>搜索区间为空的时候。<code>while(left &lt;= right)</code>的终止条件是<code>left == right +1 </code>，即<code>[right + 1, right]</code>。这时while循环结束，直接返回-1即可</p>
<p><code>while(left &lt; right)</code>的终止条件是<code>left == right</code>，写成区间的形式是<code>[right, right]</code>，比如[2,2]，这时候区间非空，还有一个数2，如果此时就终止勋魂，2没有被搜索，直接返回-1是错的。</p>
</li>
<li><p>如果非要用<code>while(left &lt; right)</code>，修改成下面jike</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> nums[left] == target? left : -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关于<code>left = mid + 1, right = mid -1</code></p>
<p>本算法采用的搜索区间是两端都闭，所以当发现mid不是要找的数时，直接去+1 or -1搜索即可</p>
</li>
<li><p>算法缺陷</p>
<p>比如 <code>nums=[1,2,2,3]</code>，要找的数是2，此算法返回的索引是2.但是如果要找到目标的左边界 1， 右边界2，无法处理。</p>
<p>当然可以找到一个target，然后左右线性搜索，是可行，但是无法保证二分查找对数级的复杂度。</p>
</li>
</ul>
<h3 id="寻找左侧边界的二分查找"><a href="#寻找左侧边界的二分查找" class="headerlink" title="寻找左侧边界的二分查找"></a>寻找左侧边界的二分查找</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">left_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length; <span class="comment">//注意</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;<span class="comment">//注意</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>while中是&lt;而不是&lt;&#x3D;</p>
<p>因为用相同的方法分析，因为<code>right = nums.length</code> 而不是 <code>nums.length - 1</code>，因此每次循环的搜索区间是<code>[left, right)</code>左闭右开</p>
<p>while循环的终止条件是<code>left == right</code>， 此时搜索区间<code>[left, left)</code>为空，所以可以正确终止</p>
</li>
<li><p>返回值为什么没有-1</p>
<p>函数的返回值即left变量的值取值区间是闭区间<code>[0, nums.length]</code>，所以简单添加两行代码就可以在正确的时候return -1;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//target 比所有数都大</span></span><br><span class="line"><span class="keyword">if</span>(left == nums.length) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//类似之前算法的处理方法</span></span><br><span class="line"><span class="keyword">return</span> nums[left] == target? left : -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为什么<code>left = mid + 1, right = mid</code></p>
<p>因为搜索区间是左闭右开，当mid被检测之后，下一步应该去mid的左侧或右侧区间搜索，即<code>[left, mid)</code>或<code>[mid+1, right)</code></p>
</li>
<li><p>返回left不是right？</p>
<p>其实都一样的，因为while的终止条件是 left &#x3D;&#x3D; right</p>
</li>
<li><p>把right也变成nums.length - 1</p>
<p>因为while的退出条件是left &#x3D; right + 1, 所以当target比nums中所有元素都大时，会存在left索引越界的情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">left_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="comment">//搜索区间为[left, right]</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="comment">//数据右侧边界</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//检查出界情况</span></span><br><span class="line">    <span class="keyword">if</span>(left &gt;= nums.length || nums[left] != target)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="寻找右侧边界的二分查找"><a href="#寻找右侧边界的二分查找" class="headerlink" title="寻找右侧边界的二分查找"></a>寻找右侧边界的二分查找</h3><p>这里还是常见的左闭右开的写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">right_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">//注意</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left - <span class="number">1</span>; <span class="comment">//注意</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>要返回-1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(l == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> nums[l - <span class="number">1</span>] == target? (l - <span class="number">1</span>): -<span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="逻辑统一"><a href="#逻辑统一" class="headerlink" title="逻辑统一"></a>逻辑统一</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binary_search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">left_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= nums.length || nums[l] != target)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">right_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="number">0</span> || nums[l-<span class="number">1</span>] != target)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二分搜索套路分析"><a href="#二分搜索套路分析" class="headerlink" title="二分搜索套路分析"></a>二分搜索套路分析</h2><h3 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h3><p>875 Koko Eating Bananas medium</p>
<p>1011 Capacity To Ship Packages Within D Days medium lock</p>
<h3 id="应用-4"><a href="#应用-4" class="headerlink" title="应用"></a>应用</h3><p>算法题一般都让你求最值，比如求吃东西的最小速度，轮船的最低运载能力，求最值的过程必然是一个搜索边界的过程。</p>
<p>【二分搜索问题的泛化】要从题目中抽象出一个自变量x，一个关于x的函数f(x)，以及一个目标值target. 要满足以下条件：</p>
<ol>
<li>f(x)必须是在x上的单调函数（单调增单调减都可以）</li>
<li>题目是让你计算满足约束条件<code>f(x)==target</code>时的x值</li>
</ol>
<h3 id="框架-3"><a href="#框架-3" class="headerlink" title="框架"></a>框架</h3><p>运用二分搜索解决具体问题的算法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数f是关于自变量x的单调函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数 在f(x)==target的约束下求x的最值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">solution</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//问自己 自变量x的最小值是多少</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> ...;</span><br><span class="line">    <span class="comment">//问自己：自变量x的最大值是多少</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> ... + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(f(mid) == target)&#123;</span><br><span class="line">            <span class="comment">//问自己：题目求左边界还是右边界</span></span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(f(mid) &lt; target)&#123;</span><br><span class="line">            <span class="comment">//问自己，怎么让f(x)大一点</span></span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(f(mid) &gt; target)&#123;</span><br><span class="line">            <span class="comment">//问自己：怎么让f(x)小一点</span></span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="田忌赛马背后的算法"><a href="#田忌赛马背后的算法" class="headerlink" title="田忌赛马背后的算法"></a>田忌赛马背后的算法</h2><h3 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h3><p>870  Advantage Shuffle medium</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>打得过就打，打不过就拿自己的垃圾和对方精锐互换</p>
<h3 id="框架-4"><a href="#框架-4" class="headerlink" title="框架"></a>框架</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length;</span><br><span class="line"></span><br><span class="line">sort(nums1); <span class="comment">//田忌的马</span></span><br><span class="line">sort(nums2); <span class="comment">//齐王的马</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从最快的马开始比</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">	<span class="keyword">if</span>(nums1[i] &gt; nums2[i])&#123;</span><br><span class="line">        <span class="comment">//比得过跟他比</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//比不过 换个垫底的来送人头</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表递归"><a href="#链表递归" class="headerlink" title="链表递归"></a>链表递归</h2><h3 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h3><p>206 Reverse Linked List Easy</p>
<p>92 Reverse Linked List II medium</p>
<h3 id="框架-5"><a href="#框架-5" class="headerlink" title="框架"></a>框架</h3><h4 id="递归反转整个链表"><a href="#递归反转整个链表" class="headerlink" title="递归反转整个链表"></a>递归反转整个链表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> reverse(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">phead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = phead.next;</span><br><span class="line">            phead.next = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> phead.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="反转链表的前N个节点"><a href="#反转链表的前N个节点" class="headerlink" title="反转链表的前N个节点"></a>反转链表的前N个节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ListNode</span> <span class="variable">successor</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//后驱节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//反转以head 为起点的n个节点，返回新的头结点</span></span><br><span class="line">ListNode <span class="title function_">reverseN</span><span class="params">(ListNode head, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//记录第n+1个节点</span></span><br><span class="line">        successor = head.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以head.next为起点，需要反转前n-1个节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> reverseN(head.next, n-<span class="number">1</span>);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    <span class="comment">//让反转之后的head节点和后面的节点连起来</span></span><br><span class="line">    head.next = successor;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="反转链表的一部分"><a href="#反转链表的一部分" class="headerlink" title="反转链表的一部分"></a>反转链表的一部分</h4><p>索引从1开始，如果 m&#x3D;1，则相当于反转链表开头的n个元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> m, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> reverseN(head, n);</span><br><span class="line">    <span class="comment">//前进到反转的起点触发base case</span></span><br><span class="line">    head.next = reverseBetween(head.next, m-<span class="number">1</span>, n-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>递归和迭代的时间复杂度都是O(N)，但是迭代的空间复杂度是O(1)，递归需要用到栈，空间复杂度是O(N)。</p>
<p>所以考虑效率的话还是迭代算法比较好</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>1.1 数组链表</p><p><a href="https://happyhappychan.github.io/2022/04/19/1.1 数组链表/">https://happyhappychan.github.io/2022/04/19/1.1 数组链表/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Happyhappy Chan</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2022-04-19</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2022-04-19</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/LeetCode/">LeetCode, </a><a class="link-muted" rel="tag" href="/tags/Fucking-algorithm/">Fucking-algorithm </a></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/04/19/1.2%20%E9%98%9F%E5%88%97%E6%A0%88/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">1.2 队列栈</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/04/19/%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%92%8C%E5%88%B7%E9%A2%98%E7%9A%84%E6%A1%86%E6%9E%B6%E6%80%9D%E7%BB%B4/"><span class="level-item">学习算法和刷题的框架思维</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/Himawali.png" alt="HappyhappyChan"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">HappyhappyChan</p><p class="is-size-6 is-block">Keep investigating</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>China Mainland</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">6</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/HappyhappyChan" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/HappyhappyChan"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:chenlh65@mail2.sysu.edu.cn"><i class="fas fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="/"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="/"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Preface"><span class="level-left"><span class="level-item">1</span><span class="level-item">Preface</span></span></a></li><li><a class="level is-mobile" href="#关于基础数据结构"><span class="level-left"><span class="level-item">2</span><span class="level-item">关于基础数据结构</span></span></a></li><li><a class="level is-mobile" href="#数组-x2F-链表"><span class="level-left"><span class="level-item">3</span><span class="level-item">数组/链表</span></span></a></li><li><a class="level is-mobile" href="#前缀和数组"><span class="level-left"><span class="level-item">4</span><span class="level-item">前缀和数组</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">题目</span></span></a></li><li><a class="level is-mobile" href="#应用"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">应用</span></span></a></li><li><a class="level is-mobile" href="#核心代码"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">核心代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#差分数组"><span class="level-left"><span class="level-item">5</span><span class="level-item">差分数组</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目-1"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">题目</span></span></a></li><li><a class="level is-mobile" href="#应用-1"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">应用</span></span></a></li><li><a class="level is-mobile" href="#框架"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">框架</span></span></a></li></ul></li><li><a class="level is-mobile" href="#双指针技巧秒杀链表"><span class="level-left"><span class="level-item">6</span><span class="level-item">双指针技巧秒杀链表</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目-2"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">题目</span></span></a></li><li><a class="level is-mobile" href="#应用-2"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">应用</span></span></a></li><li><a class="level is-mobile" href="#框架-1"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">框架</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#合并两个有序链表"><span class="level-left"><span class="level-item">6.3.1</span><span class="level-item">合并两个有序链表</span></span></a></li><li><a class="level is-mobile" href="#合并k个有序链表"><span class="level-left"><span class="level-item">6.3.2</span><span class="level-item">合并k个有序链表</span></span></a></li><li><a class="level is-mobile" href="#单链表的倒数第k个结点"><span class="level-left"><span class="level-item">6.3.3</span><span class="level-item">单链表的倒数第k个结点</span></span></a></li><li><a class="level is-mobile" href="#单链表的中点"><span class="level-left"><span class="level-item">6.3.4</span><span class="level-item">单链表的中点</span></span></a></li><li><a class="level is-mobile" href="#判断链表是否包含环"><span class="level-left"><span class="level-item">6.3.5</span><span class="level-item">判断链表是否包含环</span></span></a></li><li><a class="level is-mobile" href="#判断环的起点"><span class="level-left"><span class="level-item">6.3.6</span><span class="level-item">判断环的起点</span></span></a></li><li><a class="level is-mobile" href="#两个链表是否相交"><span class="level-left"><span class="level-item">6.3.7</span><span class="level-item">两个链表是否相交</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#双指针技巧秒杀数组"><span class="level-left"><span class="level-item">7</span><span class="level-item">双指针技巧秒杀数组</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目-3"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">题目</span></span></a></li><li><a class="level is-mobile" href="#快慢指针技巧"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">快慢指针技巧</span></span></a></li><li><a class="level is-mobile" href="#滑动窗口算法"><span class="level-left"><span class="level-item">7.3</span><span class="level-item">滑动窗口算法</span></span></a></li><li><a class="level is-mobile" href="#左右指针的常用算法"><span class="level-left"><span class="level-item">7.4</span><span class="level-item">左右指针的常用算法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#二分查找"><span class="level-left"><span class="level-item">7.4.1</span><span class="level-item">二分查找</span></span></a></li><li><a class="level is-mobile" href="#两数之和"><span class="level-left"><span class="level-item">7.4.2</span><span class="level-item">两数之和</span></span></a></li><li><a class="level is-mobile" href="#反转数组"><span class="level-left"><span class="level-item">7.4.3</span><span class="level-item">反转数组</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#滑动窗口"><span class="level-left"><span class="level-item">8</span><span class="level-item">滑动窗口</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目-4"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">题目</span></span></a></li><li><a class="level is-mobile" href="#技巧顺口溜"><span class="level-left"><span class="level-item">8.2</span><span class="level-item">技巧顺口溜</span></span></a></li><li><a class="level is-mobile" href="#框架-2"><span class="level-left"><span class="level-item">8.3</span><span class="level-item">框架</span></span></a></li></ul></li><li><a class="level is-mobile" href="#二分搜索"><span class="level-left"><span class="level-item">9</span><span class="level-item">二分搜索</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目-5"><span class="level-left"><span class="level-item">9.1</span><span class="level-item">题目</span></span></a></li><li><a class="level is-mobile" href="#应用-3"><span class="level-left"><span class="level-item">9.2</span><span class="level-item">应用</span></span></a></li><li><a class="level is-mobile" href="#技巧顺口溜-1"><span class="level-left"><span class="level-item">9.3</span><span class="level-item">技巧顺口溜</span></span></a></li><li><a class="level is-mobile" href="#二分查找框架"><span class="level-left"><span class="level-item">9.4</span><span class="level-item">二分查找框架</span></span></a></li><li><a class="level is-mobile" href="#寻找一个数-基本的二分搜索"><span class="level-left"><span class="level-item">9.5</span><span class="level-item">寻找一个数(基本的二分搜索)</span></span></a></li><li><a class="level is-mobile" href="#寻找左侧边界的二分查找"><span class="level-left"><span class="level-item">9.6</span><span class="level-item">寻找左侧边界的二分查找</span></span></a></li><li><a class="level is-mobile" href="#寻找右侧边界的二分查找"><span class="level-left"><span class="level-item">9.7</span><span class="level-item">寻找右侧边界的二分查找</span></span></a></li><li><a class="level is-mobile" href="#逻辑统一"><span class="level-left"><span class="level-item">9.8</span><span class="level-item">逻辑统一</span></span></a></li></ul></li><li><a class="level is-mobile" href="#二分搜索套路分析"><span class="level-left"><span class="level-item">10</span><span class="level-item">二分搜索套路分析</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目-6"><span class="level-left"><span class="level-item">10.1</span><span class="level-item">题目</span></span></a></li><li><a class="level is-mobile" href="#应用-4"><span class="level-left"><span class="level-item">10.2</span><span class="level-item">应用</span></span></a></li><li><a class="level is-mobile" href="#框架-3"><span class="level-left"><span class="level-item">10.3</span><span class="level-item">框架</span></span></a></li></ul></li><li><a class="level is-mobile" href="#田忌赛马背后的算法"><span class="level-left"><span class="level-item">11</span><span class="level-item">田忌赛马背后的算法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目-7"><span class="level-left"><span class="level-item">11.1</span><span class="level-item">题目</span></span></a></li><li><a class="level is-mobile" href="#思路"><span class="level-left"><span class="level-item">11.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#框架-4"><span class="level-left"><span class="level-item">11.3</span><span class="level-item">框架</span></span></a></li></ul></li><li><a class="level is-mobile" href="#链表递归"><span class="level-left"><span class="level-item">12</span><span class="level-item">链表递归</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目-8"><span class="level-left"><span class="level-item">12.1</span><span class="level-item">题目</span></span></a></li><li><a class="level is-mobile" href="#框架-5"><span class="level-left"><span class="level-item">12.2</span><span class="level-item">框架</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#递归反转整个链表"><span class="level-left"><span class="level-item">12.2.1</span><span class="level-item">递归反转整个链表</span></span></a></li><li><a class="level is-mobile" href="#反转链表的前N个节点"><span class="level-left"><span class="level-item">12.2.2</span><span class="level-item">反转链表的前N个节点</span></span></a></li><li><a class="level is-mobile" href="#反转链表的一部分"><span class="level-left"><span class="level-item">12.2.3</span><span class="level-item">反转链表的一部分</span></span></a></li></ul></li><li><a class="level is-mobile" href="#小结"><span class="level-left"><span class="level-item">12.3</span><span class="level-item">小结</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Coding/"><span class="level-start"><span class="level-item">Coding</span></span><span class="level-end"><span class="level-item tag">9</span></span></a><ul><li><a class="level is-mobile" href="/categories/Coding/Algorithm/"><span class="level-start"><span class="level-item">Algorithm</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/Coding/Web/"><span class="level-start"><span class="level-item">Web</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Reading/"><span class="level-start"><span class="level-item">Reading</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Reading/Life/"><span class="level-start"><span class="level-item">Life</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Sharing/"><span class="level-start"><span class="level-item">Sharing</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/Sharing/Life/"><span class="level-start"><span class="level-item">Life</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><figure class="media-left"><a class="image" href="/2022/08/20/2022%E6%9A%91%E5%81%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"><img src="/img/covers/2022-summer-reading1.png" alt="2022暑假阅读笔记（一）"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-08-20T07:30:16.000Z">2022-08-20</time></p><p class="title"><a href="/2022/08/20/2022%E6%9A%91%E5%81%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/">2022暑假阅读笔记（一）</a></p><p class="categories"><a href="/categories/Reading/">Reading</a> / <a href="/categories/Reading/Life/">Life</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2022/05/21/May%202022%20Diary/"><img src="/img/covers/may-2022-diary.png" alt="May 2022 Diary"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-05-21T07:37:58.000Z">2022-05-21</time></p><p class="title"><a href="/2022/05/21/May%202022%20Diary/">May 2022 Diary</a></p><p class="categories"><a href="/categories/Sharing/">Sharing</a> / <a href="/categories/Sharing/Life/">Life</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2022/04/24/April%202022%20Diary/"><img src="/img/covers/april-2022-diary.png" alt="April 2022 Diary"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-04-24T14:23:33.000Z">2022-04-24</time></p><p class="title"><a href="/2022/04/24/April%202022%20Diary/">April 2022 Diary</a></p><p class="categories"><a href="/categories/Sharing/">Sharing</a> / <a href="/categories/Sharing/Life/">Life</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2022/04/24/2.2%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"><img src="/img/covers/fucking-algorithm.png" alt="2.2 二叉搜索树"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-04-24T02:59:33.000Z">2022-04-24</time></p><p class="title"><a href="/2022/04/24/2.2%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/">2.2 二叉搜索树</a></p><p class="categories"><a href="/categories/Coding/">Coding</a> / <a href="/categories/Coding/Algorithm/">Algorithm</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2022/04/21/2.1%20%E4%BA%8C%E5%8F%89%E6%A0%91/"><img src="/img/covers/fucking-algorithm.png" alt="2.1 二叉树"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-04-21T08:34:49.000Z">2022-04-21</time></p><p class="title"><a href="/2022/04/21/2.1%20%E4%BA%8C%E5%8F%89%E6%A0%91/">2.1 二叉树</a></p><p class="categories"><a href="/categories/Coding/">Coding</a> / <a href="/categories/Coding/Algorithm/">Algorithm</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/08/"><span class="level-start"><span class="level-item">August 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">May 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">April 2022</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Book/"><span class="tag">Book</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Diary/"><span class="tag">Diary</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Fucking-algorithm/"><span class="tag">Fucking-algorithm</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LeetCode/"><span class="tag">LeetCode</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Website/"><span class="tag">Website</span><span class="tag">3</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/crayon-shinchan-logo.svg" alt="HappyhappyChan&#039;s-Blog" height="28"></a><p class="is-size-7"><span>&copy; 2022 Happyhappy Chan</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Fork Me on GitHub" href="https://github.com/HappyhappyChan"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script src="/js/night.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>